{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"about/","title":"Something","text":""},{"location":"go-study/00-mac-terminal-setup/clean-code-solid/","title":"Clean Code","text":""},{"location":"go-study/00-mac-terminal-setup/clean-code-solid/#solid-principles","title":"SOLID Principles","text":"<p>SOLID principles are 5 concepts that will help us make our programs better.</p> <ul> <li>Single Responsibility Principle</li> <li>Open / Closed Principles</li> <li>Liskov Substitution Principle</li> <li>Interface Segregation Principle</li> <li>Dependency Inversion Principle</li> </ul>"},{"location":"go-study/00-mac-terminal-setup/clean-code-solid/#single-responsibility-principle","title":"Single Responsibility Principle","text":"<p>A class should have one, and only one, reason to change. This means that a class should have only one job.</p>"},{"location":"go-study/00-mac-terminal-setup/clean-code-solid/#open-closed-principles","title":"Open / Closed Principles","text":"<p>A class should be open for extension but closed for modification. This means that we should be able to add new functionality to a class without changing the existing code.</p>"},{"location":"go-study/00-mac-terminal-setup/clean-code-solid/#liskov-substitution-principle","title":"Liskov Substitution Principle","text":"<p>Objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program. This means that we should be able to use a subclass in place of a superclass without any problems.</p>"},{"location":"go-study/00-mac-terminal-setup/clean-code-solid/#interface-segregation-principle","title":"Interface Segregation Principle","text":"<p>A class should not be forced to implement an interface that it does not use. This means that we should have small, specific interfaces instead of large, general ones.</p>"},{"location":"go-study/00-mac-terminal-setup/clean-code-solid/#dependency-inversion-principle","title":"Dependency Inversion Principle","text":"<p>High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.</p>"},{"location":"go-study/00-mac-terminal-setup/mac-terminal/","title":"Mac terminal","text":""},{"location":"go-study/00-mac-terminal-setup/mac-terminal/#turn-boring-mac-terminal-into-a-beautiful-terminal","title":"Turn Boring Mac Terminal into a Beautiful Terminal","text":"<p>Checking zsh installation on machine Install zsh using Home Brew Confirm zsh installation</p> <pre><code>echo $0\nbrew install zsh\nwhich zsh\n</code></pre> <p>install oh my zsh https://ohmyz.sh/#install</p> <p>install nerd fonts https://www.nerdfonts.com/</p> <p>install hack nerd font</p> <p>brew tap homebrew/cask-fonts brew install font-hack-nerd-font</p> <p>install power10k</p> <pre><code>\n</code></pre> <p>install zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~ /.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting</p> <p>install zsh-autosuggestion https://github.com/zsh-users/zsh-autosuggestions</p> <p>git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~ /.oh-my-zsh/custom}/plugins/zsh-autosuggestions</p> <p>git clone https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions</p> <p>Install warp</p>"},{"location":"go-study/01-go-setup/01-philosophy/","title":"Why Go?","text":""},{"location":"go-study/01-go-setup/01-philosophy/#philosophy","title":"Philosophy","text":"<ul> <li>Simplicity - Go is designed to be simple and easy to learn. It has a clean and easy-to-read syntax that makes it easy   to write and maintain code.</li> <li>Static Typing - Go is statically typed, which means that the type of a variable is known at compile time. This helps   to catch errors early in the development process.</li> <li>Compiled Language - Go is a compiled language, which means that it is fast and efficient. It is designed to be fast to   compile and fast to run, making it a good choice for performance-critical applications.</li> <li>Efficient Memory Management - Go has a garbage collector that automatically manages memory, making it easy to write   memory-safe code without worrying about memory leaks.</li> <li>Dependency Management - Go has a built-in package management system called \"go modules\" that makes it easy to manage   dependencies and share code with other developers.</li> <li>Concurrency - Go has built-in support for concurrency, which makes it easy to write programs that can do multiple   things at once. This is especially useful for writing web servers and other networked applications.</li> <li>Performance - Go is a compiled language, which means that it is fast and efficient. It is designed to be fast to   compile and fast to run, making it a good choice for performance-critical applications.</li> <li>Cloud Native - Go is designed to work well in cloud-native environments, making it a good choice for building   microservices and other cloud-based applications.</li> <li>Active Community - Go has a growing and active community of developers who are constantly working to improve the   language and its ecosystem.</li> <li>Open Source - Go is an open-source language, which means that it is free to use and can be modified and distributed by   anyone.</li> <li>Standard Library - Go has a rich standard library that provides a wide range of functionality, including networking,   file I/O, and text processing.</li> </ul>"},{"location":"go-study/01-go-setup/01-philosophy/#go-vs-java","title":"Go vs Java","text":"<p>https://go.dev/talks/2015/go-for-java-programmers.slide#2</p> <p>Golang is a multi-paradigm and better supports concurrency. While Golang runs faster than Java, Java has more features and better support. Go has a leaner learning curve as compared to Java. If simplicity and memory management are your priority, then Go is a good option</p> Parameter Golang Java Syntax has a simpler syntax with fewer keywords has a more verbose syntax Concurrency has built-in support for concurrency with goroutine and channel. light-weight has concurrency like thread.  Much more heavy-weight Compilation is a compiled language with fast compilation times is compiled language to be interpreted in JVM Garbage collection has a concurrent garbage collector Package management has a built-in package management system called \"go modules\" use external tools like Maven or Gradle Performance high-performance and low-latency slower than Golang since it runs on JVMs Community support has a growing and active community has a mature community"},{"location":"go-study/01-go-setup/01-philosophy/#go-and-java-have-much-in-common","title":"Go and Java have much in common","text":"<ul> <li>C family (imperative, braces)</li> <li>Statically typed</li> <li>Garbage collected</li> <li>Memory safe (nil references, runtime bounds checks)</li> <li>Primitive variables are always initialized (zero/nil/false)</li> <li>Methods</li> <li>Interfaces</li> <li>Type assertions (instanceof)</li> <li>Reflection</li> </ul>"},{"location":"go-study/01-go-setup/01-philosophy/#go-differs-from-java-in-several-ways","title":"Go differs from Java in several ways","text":"<ol> <li>[ ]  Programs compile to machine code. There's no VM.</li> <li>[ ]  Statically linked binaries</li> <li>[ ]  Control over memory layout</li> <li>[ ]  Function values and lexical closures</li> <li>[ ]  Built-in strings (UTF-8)</li> <li>[ ]  Built-in concurrency</li> <li>[ ]  Built-in Dependency Management</li> </ol>"},{"location":"go-study/01-go-setup/01-philosophy/#go-intentionally-leaves-out-many-features","title":"Go intentionally leaves out many features","text":"<ul> <li>No classes</li> <li>No constructors</li> <li>No inheritance</li> <li>No final</li> <li>No exceptions</li> <li>No annotations</li> </ul>"},{"location":"go-study/01-go-setup/go-for-java/","title":"Go for java","text":""},{"location":"go-study/01-go-setup/go-for-java/#golang-vs-java","title":"Golang vs Java","text":"<p>When it comes to web development, both Golang and Java have advantages and disadvantages. For web development, here is a feature-by-feature comparison \u2212</p> <p>Due to its built-in garbage collector and concurrency support, Golang is faster than Java for web development. The garbage collector in Java can cause latency issues in large-scale applications, affecting performance.</p> <p>Scalability \u2212 Because Golang is so scalable, it's an excellent choice for large-scale web applications. Scalability in Java is determined by the framework and the developer's ability to manage the application's resources.</p> <p>Simplicity \u2212 Golang is known for its simplicity and ease of use, making it an excellent choice for new programmers. Because of its extensive libraries and frameworks, Java has a steeper learning curve and can be more complex.</p> <p>Because of its extensive security features and strong type system, Java is considered more secure than Golang. For security features, Golang, on the other hand, relies on external libraries.</p> <p>Libraries and Frameworks \u2212 Java has a large number of libraries and frameworks that help developers create complex web applications. Although Golang has a smaller community and fewer libraries and frameworks, the ones that do exist are highly efficient and well-documented.</p> <p>Programming language Maturity</p> <p>Programmer Community</p> <p>Tools and Frameworks</p>"},{"location":"go-study/01-go-setup/go-for-java/#go-and-java-have-much-in-common","title":"Go and Java have much in common","text":"<ul> <li>C family (imperative, braces)</li> <li>Statically typed</li> <li>Garbage collected</li> <li>Memory safe (nil references, runtime bounds checks)</li> <li>Primitive variables are always initialized (zero/nil/false)</li> <li>Methods</li> <li>Interfaces</li> <li>Type assertions (instanceof)</li> <li>Reflection</li> </ul>"},{"location":"go-study/01-go-setup/go-for-java/#go-differs-from-java-in-several-ways","title":"Go differs from Java in several ways","text":"<ol> <li>[ ]  Programs compile to machine code. There's no VM.</li> <li>[ ]  Statically linked binaries</li> <li>[ ]  Control over memory layout</li> <li>[ ]  Function values and lexical closures</li> <li>[ ]  Built-in strings (UTF-8)</li> <li>[ ]  Built-in concurrency</li> </ol>"},{"location":"go-study/01-go-setup/go-for-java/#go-intentionally-leaves-out-many-features","title":"Go intentionally leaves out many features","text":"<ul> <li>No classes</li> <li>No constructors</li> <li>No inheritance</li> <li>No final</li> <li>No exceptions</li> <li>No annotations</li> </ul>"},{"location":"go-study/01-go-setup/go-for-java/#why-does-go-leave-out-those-features","title":"Why does Go leave out those features?","text":"<p>Clarity is critical.</p> <p>When reading code, it should be clear what the program will do.</p> <p>When writing code, it should be clear how to make the program do what you want.</p> <p>Sometimes this means writing out a loop instead of invoking an obscure function.</p> <p>(Don't DRY out.)</p> <p>For more background on design:</p> <p>Less is exponentially more (Pike, 2012) Go at Google: Language Design in the Service of Software Engineering (Pike, 2012)</p> <p>Go looks familiar to Java programmers</p> <p>Main.java</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n    System.out.println(\"Hello, world!\");\n}\n</code></pre> <p>hello.go</p> <pre><code>package main\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, \u4e16\u754c!\")\n}\n</code></pre> <p>Hello, web server</p> <pre><code>package main\n\nimport (\n\"fmt\"\n\"log\"\n\"net/http\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/hello\", handleHello)\n    fmt.Println(\"serving on http://localhost:7777/hello\")\n    log.Fatal(http.ListenAndServe(\"localhost:7777\", nil))\n}\n\nfunc handleHello(w http.ResponseWriter, req *http.Request) {\n    log.Println(\"serving\", req.URL)\n    fmt.Fprintln(w, \"Hello, \u4e16\u754c!\")\n}\n</code></pre> <p>Types follow names in declarations. Exported names are Capitalized. Unexported names are not.</p>"},{"location":"go-study/01-go-setup/go-for-java/#goroutines","title":"Goroutines","text":"<p>Goroutines are like lightweight threads.</p> <p>They start with tiny stacks and resize as needed.</p> <p>Go programs can have hundreds of thousands of them.</p> <p>Start a goroutine using the go statement:</p> <p>go f(args) The Go runtime schedules goroutines onto OS threads.</p> <p>Blocked goroutines don't use a thread.</p>"},{"location":"go-study/01-go-setup/setup-go-env/","title":"Go Setup","text":""},{"location":"go-study/01-go-setup/setup-go-env/#download-and-install","title":"Download and Install","text":"<ol> <li>Download Go SDK here at this URL https://go.dev/doc/install</li> <li>Install Go quickly and follow the steps</li> </ol> <p>I would recommend to install Go Version Manager to manage your Go SDK. It's easy and very useful to manage multiple versions.</p>"},{"location":"go-study/01-go-setup/setup-go-env/#go-version-manager","title":"Go Version Manager","text":"<ul> <li>Simple go version manager   Go to this link and follow the instructions for   installation.</li> </ul>"},{"location":"go-study/01-go-setup/setup-go-env/#single-line-installation","title":"Single-line Installation","text":"<p>Install by curl command</p> <pre><code>curl -sSL https://git.io/g-install | sh -s\n</code></pre> <p>Validate installation</p> <pre><code>g --help\n\n  Usage: g [COMMAND] [options] [args]\n\n  Commands:\n\n    g                         Open interactive UI with downloaded versions\n    g install latest          Download and set the latest go release\n    g install &lt;version&gt;       Download and set go &lt;version&gt;\n    g download &lt;version&gt;      Download go &lt;version&gt;\n    g set &lt;version&gt;           Switch to go &lt;version&gt;\n    g run &lt;version&gt;           Run a given version of go\n    g which &lt;version&gt;         Output bin path for &lt;version&gt;\n    g remove &lt;version ...&gt;    Remove the given version(s)\n    g prune                   Remove all versions except the current version\n    g list                    Output downloaded go versions\n    g list-all                Output all available, remote go versions\n    g self-upgrade            Upgrades g to the latest version\n    g help                    Display help information, same as g --help\n\n  Options:\n\n    -h, --help                Display help information and exit\n    -v, --version             Output current version of g and exit\n    -q, --quiet               Suppress almost all output\n    -c, --no-color            Force disabled color output\n    -y, --non-interactive     Prevent prompts\n    -o, --os                  Override operating system\n    -a, --arch                Override system architecture\n    -u, --unstable            Include unstable versions in list\n</code></pre>"},{"location":"go-study/02-quick-start/get-started/","title":"Get Started","text":"<p>Create a hello directory</p> <pre><code>mkdir hello\ncd hello\n</code></pre> <p>Enable dependency tracking</p> <pre><code>go mod init example/hello\ngo: creating new go.mod: module example/hello \n</code></pre> <p>Add main.go to the project</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, Go\")\n}\n</code></pre> <p>Run your code to see the greeting</p> <pre><code>go run main.gp\n</code></pre>"},{"location":"go-study/02-quick-start/get-started/#call-code-in-an-external-package","title":"Call code in an external package","text":"<p>When you need your code to do something that might have implemented by someone else. Let's use rsc.io/quote package</p> <p>import rsc.io/quote package</p> <pre><code>package main\n\nimport \"fmt\"\n\nimport \"rsc.io/quote\"\n\nfunc main() {\n    fmt.Println(quote.Go())\n}\n</code></pre> <p>Update your dependency tracking Run your code</p> <pre><code>go mod tidy\ngo run main.go\n\nDon't communicate by sharing memory, share memory by communicating.\n</code></pre>"},{"location":"go-study/03-basics/basics/","title":"Go Basics","text":""},{"location":"go-study/03-basics/basics/#blank-identifier","title":"Blank Identifier","text":"<p>The _ (underscore character) is known as the blank identifier and has many uses within Go. It\u2019s used when you want to throw away the assignment of a value, including the assignment of an import to its package name, or ignore return values from a function when you\u2019re only interested in the others.</p>"},{"location":"go-study/03-basics/basics/#init","title":"init","text":"<p>Each package can provide as many init functions as necessary to be invoked at the beginning of execution time. All the init functions that are discovered by the compiler are scheduled to be executed prior to the main function being executed. The init functions are great for setting up packages, initializing variables, or performing any other bootstrapping you may need prior to the program running.</p>"},{"location":"go-study/03-basics/basics/#tooling","title":"Tooling","text":"<pre><code>go\n\nGo is a tool for managing Go source code.\n\nUsage:\n\n        go &lt;command&gt; [arguments]\n\nThe commands are:\n\n        bug         start a bug report\n        build       compile packages and dependencies\n        clean       remove object files and cached files\n        doc         show documentation for package or symbol\n        env         print Go environment information\n        fix         update packages to use new APIs\n        fmt         gofmt (reformat) package sources\n        generate    generate Go files by processing source\n        get         add dependencies to current module and install them\n        install     compile and install packages and dependencies\n        list        list packages or modules\n        mod         module maintenance\n        work        workspace maintenance\n        run         compile and run Go program\n        test        test packages\n        tool        run specified go tool\n        version     print Go version\n        vet         report likely mistakes in packages\n\nUse \"go help &lt;command&gt;\" for more information about a command.\n\nAdditional help topics:\n\n        buildconstraint build constraints\n        buildmode       build modes\n        c               calling between Go and C\n        cache           build and test caching\n        environment     environment variables\n        filetype        file types\n        go.mod          the go.mod file\n        gopath          GOPATH environment variable\n        goproxy         module proxy protocol\n        importpath      import path syntax\n        modules         modules, module versions, and more\n        module-auth     module authentication using go.sum\n        packages        package lists and patterns\n        private         configuration for downloading non-public code\n        testflag        testing flags\n        testfunc        testing functions\n        vcs             controlling version control with GOVCS\n</code></pre>"},{"location":"go-study/03-basics/basics/#variables-declared-without-an-initial-value-are-set-to-their-zero-values","title":"Variables declared without an initial value are set to their zero values:","text":"<ul> <li>0 for all integer types,</li> <li>0.0 for floating point numbers,</li> <li>false for booleans,</li> <li>\"\" for strings,</li> <li>nil for interfaces, slices, channels, maps, pointers and functions.</li> </ul> <p>Declare</p> <pre><code>package main\n\nimport \"fmt\"\n\n// The provided code is written in Go and demonstrates the concept of zero values\n// in the language. Zero values are default values assigned to variables that are\n// declared without an explicit initial value.\nfunc main() {\n    var n int\n    var f float32\n    var b bool\n    var s string\n    var sl []string\n\n    fmt.Printf(\"n - type: %T value: %#v\\n\", n, n)\n    fmt.Printf(\"f - type: %T value: %#v\\n\", f, f)\n    fmt.Printf(\"b - type: %T value: %#v\\n\", b, b)\n    fmt.Printf(\"s - type: %T value: %#v\\n\", s, s)\n    fmt.Printf(\"sl - type: %T value: %#v\\n\", sl, sl)\n}\n</code></pre>"},{"location":"go-study/03-basics/basics/#user-define-types","title":"User-Define Types","text":"<p>Go allows you the ability to declare your own types using keyword struct.</p> <p>Declaration of a struct type</p> <pre><code>package main\n\nimport \"fmt\"\n\n// user define-type in the program\ntype user struct {\n    name       string\n    email      string\n    ext        int\n    privileged bool\n}\n\nfunc main() {\n\n    // Initialize a variable of type user by positional parameter\n    // Must assign values to all fields.\n    // Not prefer way because not knowing what the values are assigned to the fields\n    rossi := user{\"rossi\", \"rossi@email.com\", 56, true}\n\n    // Declare a variable of type user and initialize some or all the fields\n    // prefer way because of code readability and knowing what the values are assigned to the fields\n    lisa := user{\n        name:       \"Lisa\",\n        email:      \"lisa@email.com\",\n        ext:        123,\n        privileged: true,\n    }\n\n    // You may omit assign some values to the fields.\n    // Omitted fields will be assigned the zero value of the field's type\n    barry := user{\n        name:  \"barry\",\n        email: \"barr@email.com\",\n    }\n\n    fmt.Printf(\"%v, %T\\n\", rossi, rossi)\n    fmt.Printf(\"%v, %T\\n\", lisa, lisa)\n    fmt.Printf(\"%v, %T\\n\", barry, barry)\n}\n</code></pre>"},{"location":"go-study/03-basics/basics/#methods","title":"Methods","text":"<ul> <li>has no return value</li> <li>has receiver parameter declared between keyword word and the function name</li> <li>provide a way to add behavior to user-defined types</li> <li>provide a way to access interfaces</li> </ul> <pre><code>// user defines a user in the program.\ntype user struct {\n    name string\n    email string\n}\n\n// notify implements a method with a value receiver.\nfunc (u user) notify() {\n    fmt.Printf(\"Sending User Email To %s&lt;%s&gt;\\n\",\n        u.name,\n        u.email)\n}\n\n// changeEmail implements a method with a pointer receiver.\nfunc (u *user) changeEmail(email string) {\n    u.email = email\n}\n</code></pre>"},{"location":"go-study/03-basics/basics/#function","title":"Function","text":""},{"location":"go-study/03-basics/basics/#access-modifier","title":"Access Modifier","text":"<p>In GO, there are two modifier types\u2014package &amp; public. An identifier that starts with a capital letter is public and can be accessed by anyone outside the package. Whereas, an identifier that starts with a lowercase letter is package access and can not be accessed from other packages.</p> <p>Public access modifier</p> <pre><code>package somepackage\n\n// public access\nfunc GetById(int id) int {}\nvar MyId\n</code></pre> <p>Package access modifier</p> <pre><code>// package access - only methods and functions in this package can access them\nfunc getById(int id) int {}\nvar myId\n</code></pre>"},{"location":"go-study/04-collections/array/","title":"Array","text":"<p>array - fixed-length data type</p> <p>Declaring an array set to its zero value</p> <pre><code>// Declare an integer array of five elements\nvar array [5]int\n</code></pre> <p>Declaring an array using an array literal</p> <pre><code>// Declare an integer array\n// Initialize each element with a specific value\n// Capacity is determined based on the number of values initialized\narray := [...]int{10, 20, 30, 40, 50}\n</code></pre> <p>Declaring an array initializing specific elements</p> <pre><code>// Declare an integer array of five elements\n// Initialize index 1 and 2 with specific value\n// The rest of the elements contain their zero value.\narray := [5]int{1:10, 2:20}\n</code></pre> <p>Accessing array elements</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    array := [5]int{10, 20, 30, 40, 50}\n\n    // Change the value at index 2,\n    array[2] = 35\n    fmt.Println(array)\n}\n</code></pre> <p>Accessing array pointer elements</p> <pre><code>// Declare an integer pointer array of five elements.\n// Initialize index 0 and 1 of the array with integer pointers.\narray := [5]*int{0: new(int), 1: new(int)}\n</code></pre> <p>Assigning one array to another of the same type</p> <pre><code>// Declare a string array of five elements\nvar array1 [5]string\nfmt.Println(array1)\n\n// Declare  second string array of five elements.\n// Initialize the array with colors\narray2 := [5]string{\"Red\", \"Blue\", \"Green\", \"Yellow\", \"Pink\"}\nfmt.Println(array2)\n\n// Copy the values from array2 into array1\narray1 = array2\nfmt.Println(array1)\n</code></pre> <p>Assigning one array of pointers to another</p> <pre><code>// Declare a string pointer array of three elements.\nvar array1 [3]*string\n\n// Declare a second string pointer array of three elements.\n// Initialize the array with string pointers.\narray2 := [3]*string{new(string), new(string), new(string)}\n\n// Add colors to each element\n*array2[0] = \"Red\"\n*array2[1] = \"Blue\"\n*array2[2] = \"Green\"\n\n// Copy the values from array2 into array1. both point to the same memory address\narray1 = array2\n</code></pre> <p>Declaring two-dimensional arrays</p> <pre><code>// Declare a two dimensional integer array of four elements\n// by two elements.\nvar array [4][2]int\n\n// Use an array literal to declare and initialize a two\n// dimensional integer array.\narray := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}\n\n// Declare and initialize index 1 and 3 of the outer array.\narray := [4][2]int{1: {20, 21}, 3: {40, 41}}\n\n// Declare and initialize individual elements of the outer\n// and inner array.\narray := [4][2]int{1: {0: 20}, 3: {1: 41}}\n</code></pre>"},{"location":"go-study/04-collections/array/#passing-arrays-between-functions","title":"Passing arrays between functions","text":"<p>Passing an array between functions can be an expensive operation in terms of memory and performance. When you pass variables between functions, they\u2019re always passed by value. When your variable is an array, this means the entire array, regardless of its size, is copied and passed to the function.</p>"},{"location":"go-study/04-collections/array/#passing-a-large-array-by-pointer-between-functions","title":"Passing a large array by pointer between functions","text":"<pre><code>// Allocate an array of 8 megabytes.\nvar array [1e6]int\n\n// Pass the address of the array to the function foo.\nfoo(&amp;array)\n\n// Function foo accepts a pointer to an array of one million integers.\nfunc foo(array *[1e6]int) {\n    ...\n}\n</code></pre>"},{"location":"go-study/04-collections/maps/","title":"Map","text":""},{"location":"go-study/04-collections/maps/#map","title":"Map","text":"<ul> <li>Maps are used to store data values in key:value pairs.</li> <li>The default value of a map is nil.</li> </ul> <pre><code>package main\nimport \"fmt\"\n\nfunc main() {\n    // Create a map with a key of type string and a value of type int.\n    dict := make(map[string]int)\n\n    // Create a map with a key and value of type string.\n    // Initialize the map with 2 key/value pairs.\n    dict2 := map[string]string{\"Red\": \"#da1337\", \"Orange\": \"#e95a22\"}\n    subjectMarks := map[string]float32{\"Golang\": 85, \"Java\": 80, \"Python\": 81}\n\n    fmt.Println(\"dict: \", dict)\n    fmt.Println(\"dict2: \", dict2)\n    fmt.Println(\"subjectMarks: \", subjectMarks)\n}\n</code></pre> <p>Change value of a map</p> <pre><code>package main\nimport \"fmt\"\n\nfunc main() {\n\n  // create a map\n  capital := map[string]string{ \"Nepal\": \"Kathmandu\", \"US\": \"New York\"}\n  fmt.Println(\"Initial Map: \", capital)\n\n  // change value of US to Washington DC\n  capital[\"US\"] = \"Washington DC\"\n\n  fmt.Println(\"Updated Map: \", capital)\n}\n</code></pre> <p>Add Element of Go Map Element</p> <pre><code>package main\nimport \"fmt\"\n\nfunc main() {\n\n  // create a map\n  students := map[int]string{1: \"John\", 2: \"Lily\"}\n  fmt.Println(\"Initial Map: \", students)\n\n  // add element with key 3\n  students[3] = \"Robin\"\n\n  // add element with key 5\n  students[5] = \"Julie\"\n\n  fmt.Println(\"Updated Map: \", students)\n}\n</code></pre> <p>Delete an element in map</p> <pre><code>package main\nimport \"fmt\"\n\nfunc main() {\n\n  // create a map\n  personAge := map[string]int{\"Hermione\": 21, \"Harry\": 20, \"John\": 25}\n  fmt.Println(\"Initial Map: \", personAge)\n\n  // remove element of map with key John\n  delete(personAge, \"John\")\n\n  fmt.Println(\"Updated Map: \", personAge)\n}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"go-study/04-collections/slices/","title":"Slices","text":"<p>Slices - dynamic arrays that can shrink and grow</p>"},{"location":"go-study/04-collections/slices/#make-and-slice-literals","title":"Make and slice literals","text":"<pre><code>// Create a slice of strings.\n// Contains a length and capacity of 5 elements.\nslice := make([]string, 5)\n</code></pre> <pre><code>// Create a slice of integers.\n// Contains a length of 3 and has a capacity of 5 elements.\nslice := make([]int, 3, 5)\n</code></pre> <pre><code>// Create a slice of integers.\n// Make the length larger than the capacity.\nslice := make([]int, 5, 3)\n\nCompiler Error:\nlen larger than cap in make([]int)\n</code></pre> <pre><code>// Create a slice of strings.\n// Contains a length and capacity of 5 elements.\nslice := []string{\"Red\", \"Blue\", \"Green\", \"Yellow\", \"Pink\"}\n\n// Create a slice of integers.\n// Contains a length and capacity of 3 elements.\nslice := []int{10, 20, 30}\n</code></pre> <pre><code>// Create a slice of strings.\n// Initialize the 100th element with an empty string.\nslice := []string{99: \"99\"}\n</code></pre> <p>Notice, if you specify a value inside the [ ] operator, you\u2019re creating an array. If you don\u2019t specify a value, you\u2019re creating a slice.</p> <pre><code>// Create an array of three integers.\narray := [3]int{10, 20, 30}\n\n// Create a slice of integers with a length and capacity of three.\nslice := []int{10, 20, 30}\n</code></pre> <p>Declaring a nil slice</p> <pre><code>// Create a nil slice of integers.\nvar slice []int\n</code></pre> <p>A nil slice is the most common way you create slices in Go. They can be used with many of the standard library and built-in functions that work with slices. They\u2019re useful when you want to represent a slice that doesn\u2019t exist, such as when an exception occurs in a function that returns a slice</p> <p></p> <pre><code>// Use make to create an empty slice of integers.\nslice := make([]int, 0)\n\n// Use a slice literal to create an empty slice of integers.\nslice := []int{}\n</code></pre> <p>An empty slice contains a zero-element underlying array that allocates no storage. Empty slices are useful when you want to represent an empty collection, such as when a database query returns zero results</p> <p></p>"},{"location":"go-study/04-collections/slices/#working-with-slices","title":"Working with slices","text":"<p>Declaring an array using an array literal</p> <pre><code>// Create a slice of integers.\n// Contains a length and capacity of 5 elements.\nslice := []int{10, 20, 30, 40, 50}\n\n// Change the value of index 1.\nslice[1] = 25\n</code></pre> <p>Taking the slice of a slice</p> <pre><code>// Create a slice of integers.\n// Contains a length and capacity of 5 elements.\nslice := []int{10, 20, 30, 40, 50}\n\n\n// Create a new slice.\n// Contains a length of 2 and capacity of 4 elements.\nnewSlice := slice[1:3]\n</code></pre> <p></p> <p>Calculating the length and capacity for any new slice is performed using the following formula.</p> <pre><code>For slice[i:j] with an underlying array of capacity k\n\nLength:   j - i\nCapacity: k - i\n</code></pre> <p>making changes to a slice</p> <pre><code>// Create a slice of integers.\n// Contains a length and capacity of 5 elements.\nslice := []int{10, 20, 30, 40, 50}\n\n// Create a new slice.\n// Contains a length of 2 and capacity of 4 elements.\nnewSlice := slice[1:3]\n\n// Change index 1 of newSlice.\n// Change index 2 of the original slice.\nnewSlice[1] = 35\n</code></pre> <p></p> <p>Runtime error showing index out of range</p> <pre><code>// Create a slice of integers.\n// Contains a length and capacity of 5 elements.\nslice := []int{10, 20, 30, 40, 50}\n\n// Create a new slice.\n// Contains a length of 2 and capacity of 4 elements.\nnewSlice := slice[1:3]\n\n// Change index 3 of newSlice.\n// This element does not exist for newSlice.\nnewSlice[3] = 45\n\nRuntime Exception:\npanic: runtime error: index out of range\n</code></pre> <p>Using append to add an element to a slice</p> <pre><code>// Create a slice of integers.\n// Contains a length and capacity of 5 elements.\nslice := []int{10, 20, 30, 40, 50}\n\n// Create a new slice.\n// Contains a length of 2 and capacity of 4 elements.\nnewSlice := slice[1:3]\n\n// Allocate a new element from capacity.\n// Assign the value of 60 to the new element.\nnewSlice = append(newSlice, 60)\n</code></pre> <p></p> <pre><code>// Create a slice of integers.\n// Contains a length and capacity of 4 elements.\nslice := []int{10, 20, 30, 40}\n\n// Append a new value to the slice.\n// Assign the value of 50 to the new element.\nnewSlice := append(slice, 50)\n</code></pre> <p>Using append to increase the length and capacity of a slice</p> <pre><code>// Create a slice of integers.\n// Contains a length and capacity of 4 elements.\nslice := []int{10, 20, 30, 40}\n\n// Append a new value to the slice.\n// Assign the value of 50 to the new element.\nnewSlice := append(slice, 50)\n</code></pre> <p></p>"},{"location":"go-study/04-collections/slices/#three-index-slices","title":"Three index slices","text":"<p>Declaring a slice of string using a slice literal</p> <pre><code>// Create a slice of strings.\n// Contains a length and capacity of 5 elements.\nsource := []string{\"Apple\", \"Orange\", \"Plum\", \"Banana\", \"Grape\"}\n</code></pre> <p></p> <p>Performing a three-index slice</p> <pre><code>// Slice the third element and restrict the capacity.\n// Contains a length of 1 element and capacity of 2 elements.\nslice := source[2:3:4]\n</code></pre> <p>A representation of the new slice after the operation </p> <p>How length and capacity are calculated</p> <pre><code>For slice[i:j:k]  or  [2:3:4]\n\nLength:   j - i  or  3 - 2 = 1\nCapacity: k - i  or  4 - 2 = 2\n</code></pre>"},{"location":"go-study/05-interface/interfaces/","title":"Interfaces","text":"<p>When to use interfaces: * Polymorphism * Behavior * Mocking * Generics - please use generics if you are using Go 1.18 or later.</p>"},{"location":"go-study/05-interface/interfaces/#the-empty-interface","title":"The Empty Interface","text":"<ul> <li>The interface type that specifies zero methods is known as the empty interface.</li> <li>Rob Pike says that empty interface (interface{}) says nothing.</li> </ul> <pre><code>interface{}\n</code></pre> <p>An empty interface may hold values of any type. Every type implements at least zero methods.</p> <p>Empty interfaces are used by code that handles values of an unknown type. For example, fmt.Print takes any number of arguments of type interface{}.</p> <p>Example:  The describe function in the following code accepts an empty interface as an argument. It prints the value and the type of the argument passed to it. Its application is similar to generics which available in Go 1.18.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var i interface{}\n    describe(i)\n\n    i = 42\n    describe(i)\n\n    i = \"hello\"\n    describe(i)\n}\n\nfunc describe(i interface{}) {\n    fmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n</code></pre> <p>An interface type is defined as a set of method signatures. When a type provides definition for all the methods in the interface, it is said to implement the interface. It is much similar to the OOP world. Interface specifies what methods a type should have and the type decides how to implement these methods.</p> <p>A value of interface type can hold any value that implements those methods.</p>"},{"location":"go-study/05-interface/reflection/","title":"Reflection","text":"<p>Reflection is the ability of a program to introspect and analyze its structure during run-time. In Go language, reflection is primarily carried out with types. The reflect package offers all the required APIs/Methods for this purpose. Reflection is often termed as a method of metaprogramming.</p> <pre><code>Clear is better than clever. Reflection is never clear.\n</code></pre> <p>Reflection is a very powerful and advanced concept in Go, and it should be used with care. It is very difficult to write clear and maintainable code using reflection. It should be avoided wherever possible and should be used only when necessary.</p>"},{"location":"go-study/06-generics/generics/","title":"Generics","text":"<p>Generics were proposed a few years ago in Go Forum, and they have finally been accepted into the language. The feature is in Go 1.18 version.</p> <p>What do generics really changed in Go?<p></p> Generics allow our functions and data structures to take in several types that are defined in their generic forms.</p> <p>Let's say you need a function that takes one slice of string and prints it. Then you might write this type of function:</p> <pre><code>func Print(s []string) {\n    for _, v := range s {\n        fmt.Print(v)    \n    }\n}\n</code></pre> <p>What if we want to have the slice of integer? You will need to make a new method for that:</p> <pre><code>func Print(s []int) {\n    for _, v := range s {\n        fmt.Print(v)    \n    }\n}\n</code></pre> <p>This might see redundant. Therefore, Go 1.18 offers generics. Here is the function might look like this:</p> <pre><code>func Print[T any](s []T) {\n    for _, v := range s {\n        fmt.Print(v)\n    }\n}\n</code></pre> <ol> <li>We have T, which is the type of any keyword (this keyword is specifically defined as part of a generic, which    indicates any type)</li> <li>And our parameter, where we have variable s whose type is a slice of T .</li> </ol> <p>Problem: create add two numbers function func(a, b)</p> <p>without generics:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    result := addFloat(4.82, 8.94)\n    fmt.Printf(\"result: %v\\n\", result)\n}\n\nfunc addInt(a int, b int) int {\n    return a + b\n}\n\nfunc addFloat(a float64, b float64) float64 {\n    return a + b\n}\n</code></pre> <p>applying generics:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    result := add(5, 15)\n    fmt.Printf(\"result: %v\\n\", result)\n}\n\nfunc add[T int | float64](a T, b T) T {\n    return a + b\n}\n</code></pre> <p>The parameter type: T int | float64 is verbose. There are several of the int and float like int32, float32, etc. You could do this:</p> <pre><code>type Num interface {\n    int | int8 | int16 | float32 | float64\n}\n\nfunc add[T Num](a T, b T) T {\n    return a + b\n}\n</code></pre> <p>Better way that Go provides:</p> <p>Ordered is a constraint that permits any ordered type: any type that supports the operators &lt; &lt;= &gt;= &gt;. If future releases of Go add new ordered types, this constraint will be modified to include them.</p> <pre><code>T constraintts.Ordered\n</code></pre>"},{"location":"go-study/06-generics/generics/#map-generics","title":"Map Generics","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\ntype GenericMap[T comparable, V int | string] map[T]V\n\nfunc main() {\n    m := make(GenericMap[string, int])\n    m[\"abc\"] = 7\n    fmt.Printf(\"result: %v\\n\", m)\n\n    m2 := make(GenericMap[string, string])\n    m2[\"abc\"] = \"seven\"\n    fmt.Printf(\"result: %v\\n\", m2)\n}\n</code></pre>"},{"location":"go-study/06-generics/generics/#struct-generics","title":"Struct Generics","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"golang.org/x/exp/constraints\"\n)\n\ntype CustomData interface {\n    constraints.Ordered | []byte\n}\n\ntype User[T CustomData] struct {\n    ID   int\n    Name string\n    Data T\n}\n\nfunc main() {\n    u := User[int]{\n        ID:   0,\n        Name: \"int\",\n        Data: 2,\n    }\n    fmt.Printf(\"int user: %v\\n\", u)\n\n    ustring := User[string]{\n        ID:   1,\n        Name: \"string\",\n        Data: \"two\",\n    }\n\n    fmt.Printf(\"int user: %v\\n\", ustring)\n}\n</code></pre>"},{"location":"go-study/07-concurrency/01-concurrency/","title":"Currency","text":"<p>What is Concurrency? * Concurrency is the composition of independently executing computations. * Concurrency is a way to structure software, particularly as a way to write clean code that interacts well with the   real world. * Concurrency is not parallelism. It is about the design. * Parallelism is the property of a system where several computations can execute simultaneously.</p> <p>Concurrency is not parallelism * Design your program as a collection of independent processes * Design these processes to eventually run in parallel * Design your code so that the outcome is always the same</p> <p>A semaphore is a variable or abstract data type used to control access to a common resource by multiple threads and avoid critical section problems in a concurrent system such as a multitasking operating system.</p>"},{"location":"go-study/07-concurrency/01-concurrency/#communicating-sequential-processes-csp","title":"Communicating Sequential Processes (CSP)","text":"<ul> <li>Tony Hoare, 1978</li> <li>Each process is built for sequential execution</li> <li>Data is communicated between processes via channels. No shared state!</li> <li>Scale by adding more of the same</li> </ul>"},{"location":"go-study/07-concurrency/01-concurrency/#gos-concurrency-toolset","title":"Go's Concurrency Toolset","text":"<ul> <li>go routine</li> <li>channels</li> <li>select</li> <li>sync package</li> </ul>"},{"location":"go-study/07-concurrency/01-concurrency/#go-routine","title":"Go Routine","text":"<ul> <li>A go routine is a lightweight thread of function or method managed by the Go runtime.</li> </ul>"},{"location":"go-study/07-concurrency/01-concurrency/#channels","title":"Channels","text":"<ul> <li>Think of a bucket chain</li> <li>3 components: sender, buffer, receiver</li> <li>The buffer is optional</li> </ul> <p>Closing channels * Close sends a special \"closed\" message * The receiver will at some point see \"closed\". Yay! nothing to do * if you try to send more. panic!</p> <p></p>"},{"location":"go-study/07-concurrency/01-concurrency/#closing-channels","title":"Closing Channels","text":"<pre><code>package somepackage\n\nimport \"fmt\"\n\nfunc someFunc() {\n  c := make(chan int)\n  close(c)\n\n  fmt.Println(&lt;-c)\n}\n\n// what is printed?\n\n// 0, false\n\n// a receiver always returns two values\n// 0 as it is the zero value of int\n// false because, \"no more data or \"returned value is not valid\"\n\n// suggest that always close the channel from sending side.\n</code></pre>"},{"location":"go-study/07-concurrency/01-concurrency/#select","title":"Select","text":"<ul> <li>like a switch statement on channel operations</li> <li>The order of cases doesn't matter at all</li> <li>There is a default case, too</li> <li>The first not-blocking case is chosen (send and/or receive)</li> </ul> <pre><code>package main\n\nimport (\n  \"fmt\"\n  \"sync\"\n)\n\nfunc main() {\n  var count int\n  var lock sync.Mutex\n\n  increment := func() {\n    lock.Lock()\n    defer lock.Unlock()\n    count++\n    fmt.Printf(\"Incrementing: %d\\n\", count)\n  }\n\n  decrement := func() {\n    lock.Lock()\n    defer lock.Unlock()\n    count--\n    fmt.Printf(\"Decrementing: %d\\n\", count)\n  }\n\n  // Increment\n  var arithmetic sync.WaitGroup\n  for i := 0; i &lt;= 5; i++ {\n    arithmetic.Add(1)\n    go func() {\n      defer arithmetic.Done()\n      increment()\n    }()\n  }\n\n  // Decrement\n  for i := 0; i &lt;= 5; i++ {\n    arithmetic.Add(1)\n    go func() {\n      defer arithmetic.Done()\n      decrement()\n    }()\n  }\n  arithmetic.Wait()\n  fmt.Println(\"Arithmetic complete.\")\n}\n</code></pre> <p>Making channels non-blocking</p> <pre><code>package somepackage\n\nimport \"time\"\n\nfunc TryReceiveWithTimeout(c &lt;- chan int, duration time.Duration) (data int, more, ok bool) {\n    select {\n    case data, more = &lt;-c:\n          return data, more, true\n    default:                        // processed when c is blocking\n          return 0, true, false\n    }\n}\n</code></pre> <p>Shape your data flow</p> <ul> <li>Channels are streams of data</li> <li>Dealing with multiple streams is the true of select</li> </ul> <p></p> <p>Fan-out</p> <pre><code>func Fanout(In &lt;- chan int, OutA, OutB chan int) {  // Receive until closed\n    for data := range In {\n        select: {               // Send to the first non-blocking channel\n        case OutA &lt;- data:\n        case OutB &lt;- data:\n        }\n    }\n}\n</code></pre> <p>Turnout</p> <pre><code>package somepackage\n\nfunc Turnout(InA, InB &lt;- chan int, OutA, OutB chan int) {\n    // variable declaration left out for readability\n    var data int\n    var more bool\n\n    for {\n      select {                    // Receive from first non-blocking\n      case data, more = &lt;-InA:\n      case data, more = &lt;-InB:\n      }\n      if !more {\n        return\n      }\n      select {                     // Send to the first non-blocking\n      case OutA &lt;-data:\n      case OutB &lt;-data:\n      }\n    }\n}   \n</code></pre> <p>Turnout with Quit</p> <pre><code>func Turnout(Quit &lt;- chan int, InA, InB &lt;- chan int, OutA, OutB chan int) {\n    // variable declaration left out for readability\n    for {\n      select {                    // Receive from first non-blocking\n      case data, more = &lt;-InA:\n      case data, more = &lt;-InB:\n\n      case &lt;- Quit:             // remember: close generates a message\n        close(InA)              // Actually this is an anti-pattern\n        close(inB)              // but you can argue that quit acts as a delegate\n\n        Fanout(InA, OutA, OutB)     // flush the remaining data\n        Fanout(InB, OutA, OutB)\n        return\n      }\n    }\n}   \n</code></pre>"},{"location":"go-study/07-concurrency/01-concurrency/#where-channels-fail","title":"Where Channels Fail","text":"<ul> <li>you can create deadlock with channels</li> <li>Channels pass around copies, which can impact performance</li> <li>Passing pointers to channels can create race conditions</li> <li>What about \"naturally shared\" structures like caches or registries?</li> </ul>"},{"location":"go-study/07-concurrency/01-concurrency/#mutexes-are-not-an-optimal-solution","title":"Mutexes are not an optimal solution","text":"<ul> <li>Mutexes are like toilets - the longer you occupy them, the longer the queue gets</li> <li>Read/write mutexes can only reduce the problem</li> <li>Using multiple mutexes will cause deadlocks sooner or later</li> <li>All-in-all not the solution we're looking for</li> </ul>"},{"location":"go-study/07-concurrency/01-concurrency/#three-shades-of-code","title":"Three shades of code","text":"<ul> <li>Blocking = your program may get locked up (for undefined time)</li> <li>Lock free = At least one part of your program is always making progress</li> <li>Wait free = All parts of your programs are always making progress</li> </ul>"},{"location":"go-study/07-concurrency/01-concurrency/#atomic-operations","title":"Atomic operations","text":"<ul> <li>sync.atomic package</li> <li>Store, Load, Add, Swap and CompareAndSwap</li> <li>Mapped to thread-safe CPU instructions</li> <li>These instructions only work on integer types</li> <li>Only about 10-60x slower than their non-atomic counterparts</li> </ul>"},{"location":"go-study/07-concurrency/01-concurrency/#spinning-cas","title":"Spinning CAS","text":"<ul> <li>you need a state variable and a \"free\" constant</li> <li>use CAS (CompareAndSwap) in a loop:<ul> <li>if state is not free: try again until it is</li> <li>if state is free, set it to something else</li> </ul> </li> <li>if you managed to change the state, you \"own\" it</li> </ul>"},{"location":"go-study/07-concurrency/01-concurrency/#ticket-storage","title":"Ticket Storage","text":"<ul> <li>We need to indexed data structure, a ticket and a done variable</li> <li>A function draws a new ticket by adding 1 to the ticket</li> <li>Evey ticket number is unique as we never decrement</li> <li>Treat the ticket as an index to store your data</li> <li>Increase done to extend the \"ready to read\" range</li> </ul> <pre><code>type TicketStore struct {\n  ticket *uint64\n  done   *uint64\n  slots  []string // for simplicity: imagine this to be infinite\n}\n\nfunc (ts *TicketStore) Put(s string) {\n    t := atomic.AddUint64(ts.ticket, 1) - 1 // draw a ticket\n    ts.slots[t] = s                            // store your data\n\n    for !atomic.CompareAndSwapUint64(ts.done, t, t+1) {\n    runtime.Gosched()\n    }\n}\n\nfunc (ts *TicketStore) GetDone() []string {\n    return ts.slots[:atomic.LoadUint64(ts.done) + 1]            //read up to done\n}\n</code></pre>"},{"location":"go-study/07-concurrency/01-concurrency/#debugging-non-blocking-code","title":"Debugging non-blocking code","text":"<ul> <li>I call it \"the instruction pointer game\"</li> <li>The rules:<ul> <li>Pull up two windows (= two go routines) with the same code</li> <li>you have one instruction pointer that iterates through your code</li> <li>You may switch windows at any instruction</li> <li>Watch your variables for race conditions</li> </ul> </li> </ul>"},{"location":"go-study/07-concurrency/01-concurrency/#guidelines-for-non-blocking-code","title":"Guidelines for non-blocking code","text":"<ul> <li>Don't switch between atomic and non-atomic functions</li> <li>Target and exploit situations which enforce uniqueness</li> <li>Avoid changing two things at a time<ul> <li>Sometimes you can exploit bit operations</li> <li>Sometimes intelligent ordering can do the trick</li> <li>Sometimes it's just not possible at all</li> </ul> </li> </ul>"},{"location":"go-study/07-concurrency/01-concurrency/#concurrency-in-practice","title":"Concurrency in practice","text":"<ul> <li>Avoid blocking, avoid race conditions</li> <li>Use channels to avoid shared state. Use select to manage channels</li> <li>Where channels don't work:<ul> <li>Try to use tools from the sync package first</li> <li>In simple cases or when really needed: try lockless code</li> </ul> </li> </ul>"},{"location":"go-study/07-concurrency/01-concurrency/#ticket-storage_1","title":"Ticket storage","text":""},{"location":"go-study/07-concurrency/01-concurrency/#for-select-loop","title":"for-select loop","text":""},{"location":"go-study/07-concurrency/01-concurrency/#done-channel","title":"done channel","text":"<p>Done channel is a channel that is used to signal that a goroutine has completed its work.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc main() {\n    var wg sync.WaitGroup\n    done := make(chan struct{})\n\n    for i := 0; i &lt; 3; i++ {\n        wg.Add(1)\n        go func(i int) {\n            defer wg.Done()\n            fmt.Printf(\"worker %v: started\\n\", i)\n            &lt;-done\n            fmt.Printf(\"worker %v: done\\n\", i)\n        }(i)\n    }\n\n    wg.Wait()\n    fmt.Println(\"all workers done\")\n}\n</code></pre>"},{"location":"go-study/07-concurrency/01-concurrency/#pipeline","title":"pipeline","text":"<p>Create a pipeline of functions that operate on data</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // input\n    nums := []int{2, 3, 4, 7, 1}\n    // stage 1\n    dataChannel := sliceToChannel(nums)\n    // stage 2\n    finalChannel := square(dataChannel)\n    //stage 3\n    for n := range finalChannel {\n        fmt.Printf(\"result: %v\\n\", n)\n    }\n}\n\nfunc sliceToChannel(nums []int) &lt;-chan int {\n    out := make(chan int)\n    go func() {\n        for _, n := range nums {\n            fmt.Printf(\"input: %v\\n\", n)\n            out &lt;- n\n        }\n        close(out)\n    }()\n\n    return out\n}\n\n// square\n// input: channel\n// output: channel\nfunc square(in &lt;-chan int) &lt;-chan int {\n    out := make(chan int)\n    go func() {\n        for n := range in {\n            out &lt;- n * n\n        }\n        close(out)\n    }()\n\n    return out\n}\n</code></pre>"},{"location":"go-study/07-concurrency/concurrency/","title":"Currency Patterns","text":"<p>What is Concurrency?</p> <ul> <li>Concurrency is the composition of independently executing computations.</li> <li>Concurrency is a way to structure software, particularly as a way to write clean code that interacts well with the   real world.</li> <li>Concurrency is not parallelism. It is about the design.</li> </ul> <p>parallelism is the property of a system where several computations can execute simultaneously.</p> <p>Concurrency is not parallelism * Design your program as a collection of independent processes * Design these processes to eventually run in parallel * Design your code so that the outcome is always the same</p> <p>A semaphore is a variable or abstract data type used to control access to a common resource by multiple threads and avoid critical section problems in a concurrent system such as a multitasking operating system.</p> <p>Concurrency in Detail</p> <ul> <li>group code (and data) by identifying independent tasks</li> <li>no race conditions - leads to unpredictable outcomes</li> <li>no deadlock - leads to no outcome</li> <li>more worker = faster execution: scalability</li> </ul> <p>Communicating Sequential Processes (CSP)</p> <ul> <li> <p>Tony Hoare, 1978</p> </li> <li> <p>Each process is built for sequential execution</p> </li> <li>Data is communicated between processes via channels. No shared state!</li> <li>Scale by adding more of the same</li> </ul> <p>Go's Concurrency Toolset</p> <ul> <li>go routine</li> <li>channels</li> <li>select</li> <li>sync package</li> </ul> <p>Channels</p> <ul> <li>Think of a bucket chain</li> <li>3 components: sender, buffer, receiver</li> <li>The buffer is optional</li> </ul> <p></p> <p>unbuffered channel is blocked when no data sent or received</p> <p>Blocking breaks concurrency</p> <ul> <li>Remember?<ul> <li>no deadlock?</li> <li>more workers = faster execution</li> </ul> </li> <li>Blocking can lead to deadlock</li> <li>Blocking can prevent scaling</li> </ul> <p>Closing channels</p> <ul> <li>Close sends a special \"closed\" message</li> <li>The receiver will at some point see \"closed\". Yay! nothing to do</li> <li>if you try to send more. panic!</li> </ul> <p></p>"},{"location":"go-study/07-concurrency/concurrency/#closing-channels","title":"Closing Channels","text":"<pre><code>package somepackage\n\nimport \"fmt\"\n\nfunc someFunc() {\n  c := make(chan int)\n  close(c)\n\n  fmt.Println(&lt;-c)\n}\n\n// what is printed?\n\n// 0, false\n\n// a receiver always returns two values\n// 0 as it is the zero value of int\n// false because, \"no more data or \"returned value is not valid\"\n\n// suggest that always close the channel from sending side.\n</code></pre>"},{"location":"go-study/07-concurrency/concurrency/#select","title":"Select","text":"<ul> <li>like a switch statement on channel operations</li> <li>The order of cases doesn't matter at all</li> <li>There is a default case, too</li> <li>The first not-blocking case is chosen (send and/or receive)</li> </ul> <pre><code>package main\n\nimport (\n  \"fmt\"\n  \"sync\"\n)\n\nfunc main() {\n  var count int\n  var lock sync.Mutex\n\n  increment := func() {\n    lock.Lock()\n    defer lock.Unlock()\n    count++\n    fmt.Printf(\"Incrementing: %d\\n\", count)\n  }\n\n  decrement := func() {\n    lock.Lock()\n    defer lock.Unlock()\n    count--\n    fmt.Printf(\"Decrementing: %d\\n\", count)\n  }\n\n  // Increment\n  var arithmetic sync.WaitGroup\n  for i := 0; i &lt;= 5; i++ {\n    arithmetic.Add(1)\n    go func() {\n      defer arithmetic.Done()\n      increment()\n    }()\n  }\n\n  // Decrement\n  for i := 0; i &lt;= 5; i++ {\n    arithmetic.Add(1)\n    go func() {\n      defer arithmetic.Done()\n      decrement()\n    }()\n  }\n  arithmetic.Wait()\n  fmt.Println(\"Arithmetic complete.\")\n}\n</code></pre> <p>Making channels non-blocking</p> <pre><code>package somepackage\n\nimport \"time\"\n\nfunc TryReceiveWithTimeout(c &lt;- chan int, duration time.Duration) (data int, more, ok bool) {\n    select {\n    case data, more = &lt;-c:\n          return data, more, true\n    default:                        // processed when c is blocking\n          return 0, true, false\n    }\n}\n</code></pre> <p>Shape your data flow</p> <ul> <li>Channels are streams of data</li> <li>Dealing with multiple streams is the true of select</li> </ul> <p></p> <p>Fan-out</p> <pre><code>func Fanout(In &lt;- chan int, OutA, OutB chan int) {  // Receive until closed\n    for data := range In {\n        select: {               // Send to the first non-blocking channel\n        case OutA &lt;- data:\n        case OutB &lt;- data:\n        }\n    }\n}\n</code></pre> <p>Turnout</p> <pre><code>package somepackage\n\nfunc Turnout(InA, InB &lt;- chan int, OutA, OutB chan int) {\n    // variable declaration left out for readability\n    var data int\n    var more bool\n\n    for {\n      select {                    // Receive from first non-blocking\n      case data, more = &lt;-InA:\n      case data, more = &lt;-InB:\n      }\n      if !more {\n        return\n      }\n      select {                     // Send to the first non-blocking\n      case OutA &lt;-data:\n      case OutB &lt;-data:\n      }\n    }\n}   \n</code></pre> <p>Turnout with Quit</p> <pre><code>func Turnout(Quit &lt;- chan int, InA, InB &lt;- chan int, OutA, OutB chan int) {\n    // variable declaration left out for readability\n    for {\n      select {                    // Receive from first non-blocking\n      case data, more = &lt;-InA:\n      case data, more = &lt;-InB:\n\n      case &lt;- Quit:             // remember: close generates a message\n        close(InA)              // Actually this is an anti-pattern\n        close(inB)              // but you can argue that quit acts as a delegate\n\n        Fanout(InA, OutA, OutB)     // flush the remaining data\n        Fanout(InB, OutA, OutB)\n        return\n      }\n    }\n}   \n</code></pre>"},{"location":"go-study/07-concurrency/concurrency/#where-channels-fail","title":"Where Channels Fail","text":"<ul> <li>you can create deadlock with channels</li> <li>Channels pass around copies, which can impact performance</li> <li>Passing pointers to channels can create race conditions</li> <li>What about \"naturally shared\" structures like caches or registries?</li> </ul>"},{"location":"go-study/07-concurrency/concurrency/#mutexes-are-not-an-optimal-solution","title":"Mutexes are not an optimal solution","text":"<ul> <li>Mutexes are like toilets - the longer you occupy them, the longer the queue gets</li> <li>Read/write mutexes can only reduce the problem</li> <li>Using multiple mutexes will cause deadlocks sooner or later</li> <li>All-in-all not the solution we're looking for</li> </ul>"},{"location":"go-study/07-concurrency/concurrency/#three-shades-of-code","title":"Three shades of code","text":"<ul> <li>Blocking = your program may get locked up (for undefined time)</li> <li>Lock free = At least one part of your program is always making progress</li> <li>Wait free = All parts of your programs are always making progress</li> </ul>"},{"location":"go-study/07-concurrency/concurrency/#atomic-operations","title":"Atomic operations","text":"<ul> <li>sync.atomic package</li> <li>Store, Load, Add, Swap and CompareAndSwap</li> <li>Mapped to thread-safe CPU instructions</li> <li>These instructions only work on integer types</li> <li>Only about 10-60x slower than their non-atomic counterparts</li> </ul>"},{"location":"go-study/07-concurrency/concurrency/#spinning-cas","title":"Spinning CAS","text":"<ul> <li>you need a state variable and a \"free\" constant</li> <li>use CAS (CompareAndSwap) in a loop:<ul> <li>if state is not free: try again until it is</li> <li>if state is free, set it to something else</li> </ul> </li> <li>if you managed to change the state, you \"own\" it</li> </ul>"},{"location":"go-study/07-concurrency/concurrency/#ticket-storage","title":"Ticket Storage","text":"<ul> <li>We need to indexed data structure, a ticket and a done variable</li> <li>A function draws a new ticket by adding 1 to the ticket</li> <li>Evey ticket number is unique as we never decrement</li> <li>Treat the ticket as an index to store your data</li> <li>Increase done to extend the \"ready to read\" range</li> </ul> <pre><code>type TicketStore struct {\n  ticket *uint64\n  done   *uint64\n  slots  []string // for simplicity: imagine this to be infinite\n}\n\nfunc (ts *TicketStore) Put(s string) {\n    t := atomic.AddUint64(ts.ticket, 1) - 1 // draw a ticket\n    ts.slots[t] = s                            // store your data\n\n    for !atomic.CompareAndSwapUint64(ts.done, t, t+1) {\n    runtime.Gosched()\n    }\n}\n\nfunc (ts *TicketStore) GetDone() []string {\n    return ts.slots[:atomic.LoadUint64(ts.done) + 1]            //read up to done\n}\n</code></pre>"},{"location":"go-study/07-concurrency/concurrency/#debugging-non-blocking-code","title":"Debugging non-blocking code","text":"<ul> <li>I call it \"the instruction pointer game\"</li> <li>The rules:<ul> <li>Pull up two windows (= two go routines) with the same code</li> <li>you have one instruction pointer that iterates through your code</li> <li>You may switch windows at any instruction</li> <li>Watch your variables for race conditions</li> </ul> </li> </ul>"},{"location":"go-study/07-concurrency/concurrency/#guidelines-for-non-blocking-code","title":"Guidelines for non-blocking code","text":"<ul> <li>Don't switch between atomic and non-atomic functions</li> <li>Target and exploit situations which enforce uniqueness</li> <li>Avoid changing two things at a time<ul> <li>Sometimes you can exploit bit operations</li> <li>Sometimes intelligent ordering can do the trick</li> <li>Sometimes it's just not possible at all</li> </ul> </li> </ul>"},{"location":"go-study/07-concurrency/concurrency/#concurrency-in-practice","title":"Concurrency in practice","text":"<ul> <li>Avoid blocking, avoid race conditions</li> <li>Use channels to avoid shared state. Use select to manage channels</li> <li>Where channels don't work:<ul> <li>Try to use tools from the sync package first</li> <li>In simple cases or when really needed: try lockless code</li> </ul> </li> </ul>"},{"location":"go-study/07-concurrency/concurrency/#ticket-storage_1","title":"Ticket storage","text":""},{"location":"go-study/07-concurrency/concurrency/#for-select-loop","title":"for-select loop","text":""},{"location":"go-study/07-concurrency/concurrency/#done-channel","title":"done channel","text":""},{"location":"go-study/07-concurrency/concurrency/#pipeline","title":"pipeline","text":""},{"location":"go-study/07-concurrency/effective-concurrency/","title":"Effective Concurrency","text":""},{"location":"go-study/07-concurrency/effective-concurrency/#goroutine","title":"Goroutine","text":"<p>Goroutine is an execution context that is managed by the Go runtime ( as opposed to a thread that is managed by the operating system). A goroutine usually has a much smaller startup overhead than operating system thread.</p> <pre><code>go f()\ngo g(i, j)\ngo func() {\n    ...\n}()\n\ngo func(i, j int) {\n\n}(1, 2)\n</code></pre> <p>The number of operating system threads used by the runtime is equal to the number of processors/cores on the platform (unless you change this by setting the GOMAXPROCS environment variable or by calling runtime.GOMAXPROCS function). A goroutine starts with a small task. After version 1.19, goroutine size is about 2K.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc f() {\n  fmt.Println(\"Hello from goroutine\")\n}\nfunc main() {\n  go f()\n  fmt.Println(\"Hello from main\")\n  time.Sleep(100)\n}\n</code></pre> <p>A race condition occurs when two or more threads can access shared data and they try to change it at the same time. </p>"},{"location":"go-study/07-concurrency/1-goroutine/advance_concurrency/","title":"Advanced Concurrency","text":""},{"location":"go-study/07-concurrency/1-goroutine/advance_concurrency/#review","title":"Review","text":"<p>Goroutine are independently executing functions in the same address space.</p> <pre><code>go f()\ngo g(1,2)\n</code></pre> <p>Channels are typed values that allow goroutines to synchronize and exchange information</p> <pre><code>c := make(chan int)  // create un-buffer int channel\ngo func() {\n    c &lt;- 3          // send int 3 to the channel\n}\n\nn := &lt;-c            // n receive int value from the channel\n</code></pre> <p>Build long-live system, use select statement</p> <pre><code>select {\n    case xc &lt;- x;\n        // sent x on xc \n    case y := &lt;- yc\n        // received y from yc\n}\n</code></pre>"},{"location":"go-study/07-concurrency/1-goroutine/concurrency/","title":"Concurrency","text":"<p>goroutines - to execute tasks independently, potentially in parallel channels - for communication, synchronization between goroutines</p> <pre><code>package main\n\nfunc main() {\n   tasks := getTasks()\n\n   // Process each task.\n   for _, task := range tasks {\n      process(task)\n   }\n\n}\n</code></pre>"},{"location":"go-study/07-concurrency/1-goroutine/concurrency/#waitgroup","title":"WaitGroup","text":"<p>WaitGroup is a great way to wait for a set of concurrent operations to complete when you either don\u2019t care about the result of the concurrent operation, or you have other means of collecting their results. If neither of those conditions are true, I suggest you use channels and a select statement instead.</p> <p>You can think of a WaitGroup like a concurrent-safe counter: calls to Add increment the counter by the integer passed in, and calls to Done decrements the counter by one. Calls to Wait block until the counter is zero.</p>"},{"location":"go-study/07-concurrency/1-goroutine/concurrency/#mutex-rwmutex","title":"Mutex @ RWMutex","text":"<p>Mutex stands for \"mutual exclusion\" and is a way to guard critical sections of your program. Mutex creates a share memory and provides a synchronized access to that memory.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc main() {\n    var count int\n    var lock sync.Mutex\n\n    increment := func() {\n        lock.Lock()\n        defer lock.Unlock()\n        count++\n        fmt.Printf(\"Incrementing: %d\\n\", count)\n    }\n\n    decrement := func() {\n        lock.Lock()\n        defer lock.Unlock()\n        count--\n        fmt.Printf(\"Decrementing: %d\\n\", count)\n    }\n\n    // Increment\n    var arithmetic sync.WaitGroup\n    for i := 0; i &lt;= 5; i++ {\n        arithmetic.Add(1)\n        go func() {\n            defer arithmetic.Done()\n            increment()\n        }()\n    }\n\n    // Decrement\n    for i := 0; i &lt;= 5; i++ {\n        arithmetic.Add(1)\n        go func() {\n            defer arithmetic.Done()\n            decrement()\n        }()\n    }\n    arithmetic.Wait()\n    fmt.Println(\"Arithmetic complete.\")\n}\n</code></pre>"},{"location":"go-study/07-concurrency/1-goroutine/concurrency/#channels-are","title":"channels are","text":"<ul> <li>goroutine-safe</li> <li>store and pass values between goroutines</li> <li>provide FIFO semantics</li> <li>can cause goroutines to block and unblock</li> </ul>"},{"location":"go-study/07-concurrency/1-goroutine/concurrency/#making-channels","title":"making channels","text":"<p>buffered channel</p> <pre><code>ch := make(chan Task, 3)\n</code></pre> <p>unbuffered channel</p> <pre><code>ch := make(chan Task)\n</code></pre> <p>Send and Receive</p> <p>G1</p> <pre><code>package main;\n\nfunc main() {\n   ...\n   for _, task := range tasks {\n      taskCh &lt;- task\n   }\n}\n</code></pre> <p>G2</p> <pre><code>func worker() {\n   for {\n      task := &lt;-taskCh\n      process(task)\n   }\n}\n</code></pre>"},{"location":"go-study/07-concurrency/1-goroutine/goroutines/","title":"Goroutines","text":""},{"location":"go-study/07-concurrency/1-goroutine/goroutines/#goroutines","title":"Goroutines","text":"<p>A goroutine is a lightweight execution thread in the Go programming language and a function that executes concurrently with the rest of the program. Goroutines are incredibly cheap when compared to traditional threads as the overhead of creating a goroutine is very low</p> <p>sayHello() function never finish before main goroutine completes.</p> <pre><code>func main() {\n    fmt.Println(\"Start\")\n    go sayHello()\n    fmt.Println(\"Exit\")\n}\n\nfunc sayHello() {\n    fmt.Println(\"Hello world goroutine\")\n}\n</code></pre> <pre><code>---\ntitle: Goroutine\n---\n\nflowchart TB\n    main --&gt; |t0| id1[\"Println(start)\"]\n    id1[\"Println(start)\"] --&gt; |t0| id2(s)   \n    id2(+) --&gt;|fork t1| sayHello\n    id2(+) --&gt; |t0| id3[\"Println(exit)\"]\n    id3[\"Println(exit)\"] --&gt; |t0| exit\n    sayHello --x |t1| x\n</code></pre> <p>anonymous function syntax</p> <pre><code>func main() {\n    msg := \"Hello\";\n    go func(msg string) {\n        fmt.Println(msg)\n    }(msg)\n\n}\n</code></pre> <p>Add a sleep function to yield sayHello function sometimes to finish before exit out the main goroutine. However, this practice should be avoided at all time because goroutine execution time is non-deterministic.</p> <pre><code>func main() {\n    msg := \"Hello\";\n    go func(msg string) {\n        fmt.Println(msg)\n    }(msg)\n\n    time.Sleep(100 * time.Millisecond)\n}\n</code></pre>"},{"location":"go-study/07-concurrency/1-goroutine/goroutines/#waitgroup","title":"WaitGroup","text":"<p>sync.WaitGroup() - awaiting all goroutines to complete.</p> <pre><code>var wg = sync.WaitGroup()\n\nfunc main() {\n    msg := \"Hello\";\n    wg.Add(1)\n\n    go func(msg string) {\n        defer wg.Done()\n        fmt.Println(msg)\n    }(msg)\n\n    wg.Wait()\n}\n</code></pre> <pre><code>---\ntitle: Goroutine with WaitGroup\n---\n\nflowchart TB\n    main --&gt; |t0| id1[\"Println(start)\"]\n    id1[\"Println(start)\"] --&gt; |t0| id2(s)   \n    id2(+) --&gt;|fork t1| sayHello\n    id2(+) --&gt; |t0| WaitGroup\n    WaitGroup --&gt; |t0| id3[\"Println(exit)\"]\n    sayHello --&gt; |t1| WaitGroup\n    id3[\"Println(exit)\"] --&gt; |t0| exit\n</code></pre> <p>What happen if wg.Done is not invoked? It will be a fatal error with message = all routines are sleep - deadlock.</p> <pre><code>func main() {\n    msg := \"Hello\";\n    wg.Add(1)\n\n    go func(msg string) {\n        fmt.Println(msg)\n    }(msg)\n\n    msg = \"goodbye\"\n    wg.Wait()\n}\n</code></pre> <p>An example has two goroutines running within the for loop</p> <pre><code>var (\n    wg      = sync.WaitGroup{}\n    counter = 0\n)\n\nfunc main() {\n    // https://rxmarbles.com/\n    for i := 0; i &lt; 10; i++ {\n        wg.Add(2)\n        go sayHello()\n        go imcrement()\n    }\n\n    wg.Wait()\n}\n\nfunc sayHello() {\n    defer wg.Done()\n    fmt.Printf(\"Hello #%v\\n\", counter)\n}\n\nfunc imcrement() {\n    counter++\n    wg.Done()\n}\n</code></pre>"},{"location":"go-study/07-concurrency/1-goroutine/goroutines/#mutex","title":"Mutex","text":"<p>Mutex is one of the mechanisms to access a variable at a time to avoid conflicts. It has two methods: Lock and Unlock. But wait, this approach destroys the concurrency. We're better off not applying the goroutine to gain two aspects: simplicity and performance.</p> <pre><code>var (\n    wg      = sync.WaitGroup{}\n    counter = 0\n    mu      = sync.RWMutex{}\n)\n\nfunc main() {\n    //runtime.GOMAXPROCS(100)\n    // https://rxmarbles.com/\n    for i := 0; i &lt; 10; i++ {\n        wg.Add(2)\n        mu.RLock()\n        go sayHello()\n        mu.Lock()\n        go imcrement()\n    }\n\n    wg.Wait()\n}\n\nfunc sayHello() {\n    defer wg.Done()\n    fmt.Printf(\"Hello #%v\\n\", counter)\n    mu.RUnlock()\n}\n\nfunc imcrement() {\n    counter++\n    mu.Unlock()\n    wg.Done()\n}\n</code></pre>"},{"location":"go-study/07-concurrency/1-goroutine/goroutines/#gomaxprocs","title":"GOMAXPROCS","text":"<p>GOMAXPROCS - assign number of threads. By default, it would assign to the max number of threads available to cpu core.</p> <pre><code>func main() {\n    runtime.GOMAXPROOCS(1)\n    fmt.Printf(\"Threads: %v\\n\", runtime.GOMAXPROCS(-1))\n}\n</code></pre>"},{"location":"go-study/07-concurrency/1-goroutine/goroutines/#go-run-race","title":"go run -race","text":"<p>go run -race goroutines.go <p></p> the -race helps to track the race condition in the code very quickly</p>"},{"location":"go-study/07-concurrency/1-goroutine/overview/","title":"Concurrency","text":""},{"location":"go-study/07-concurrency/1-goroutine/overview/#waitgroups","title":"WaitGroups","text":"<pre><code>var wg = sync.Waitgroup{}\n\nwg.Add(&lt;int)\nwg.Done() // decrement counter\nwg.Wait() // Blocking\n</code></pre>"},{"location":"go-study/07-concurrency/1-goroutine/overview/#channel","title":"Channel","text":"<ul> <li>Channels are used to pass data between / synchronize goroutines, including func main</li> <li>Go philosophy: \"Don't communicate by sharing memory; share memory by communicating.\"</li> </ul> <p>Syntax</p>"},{"location":"go-study/07-concurrency/1-goroutine/overview/#unbuffered-channel","title":"unbuffered channel","text":"<pre><code>ch := make(chan string) // unbuffered string channel\n\nch &lt;- myData    // BLOCKING when no process receives the message\nmyVar &lt;- ch     // BLOCKING when no message to send\n\nclose(ch)       // optional, no longer receive messages\n</code></pre>"},{"location":"go-study/07-concurrency/1-goroutine/overview/#buffered-string-channel","title":"buffered string channel","text":"<pre><code>c := make(chan string, 3)\n\nc &lt;- \"Hello \"\nc &lt;- \"Earth \"\nc &lt;- \"from Mars \"\nc &lt;- \"from Venus\"   // Deadlock occurs when ran out of buffer\n</code></pre> <p>Select channel</p> <pre><code>for _, s := range chars {\n    select {\n    case charChannelOne &lt;- s:\n        fmt.Println(\"Channel One\")\n    case charChannelTwo &lt;- s:\n        fmt.Println(\"Channel Two\")\n    case charChannelThree &lt;- s:\n        fmt.Println(\"Channel Three\")\n    }\n}\n</code></pre> <p>runtime.GOMAXPROCS(0)</p>"},{"location":"go-study/07-concurrency/1-goroutine/overview/#race-conditions-mutexes-condition-and-atomic-variables","title":"Race Conditions: Mutexes, Condition, and Atomic Variables","text":""},{"location":"go-study/07-concurrency/1-goroutine/overview/#mutex","title":"Mutex","text":"<p>Mutually Exclusive -</p> <pre><code>mutex = sync.Mutex{}\nmutex.Lock()\nmutex.Unlock()\n</code></pre>"},{"location":"go-study/07-concurrency/1-goroutine/overview/#conditional-variables","title":"Conditional variables","text":"<pre><code>var condition = sync.NewCond(&amp;mutex)\ncondition.Signal()\ncondition.Broadcast()\ncondition.Wait()        // BLOCKING\n</code></pre>"},{"location":"go-study/07-concurrency/1-goroutine/overview/#atomic-variables","title":"Atomic variables","text":"<pre><code>atomic.AddInt32(&amp;inventory, 100)\n</code></pre> <p>equivalent to this code block</p> <pre><code>mutex.Lock()\ninventory += 100\nmutex.Unlock()\n</code></pre>"},{"location":"go-study/07-concurrency/1-goroutine/overview/#concurrency-patterns","title":"Concurrency Patterns","text":"<ul> <li>Worker Pool</li> <li>Fork &amp; Join</li> </ul>"},{"location":"go-study/07-concurrency/2-channel/channel/","title":"Channel","text":"<p>Creating a channel in Go requires the use of the built-in function make.</p> <pre><code>// Unbuffered channel of integers.\nunbuffered := make(chan int)\n\n// Buffered channel of strings.\nbuffered := make(chan string, 10)\n</code></pre>"},{"location":"go-study/07-concurrency/2-channel/channel/#unbuffered-channels","title":"Unbuffered Channels","text":"<p>An unbuffered channel is a channel with no capacity to hold any value before it\u2019s received. These types of channels require both a sending and receiving goroutine to be ready at the same instant before any send or receive operation can complete. If the two goroutines aren\u2019t ready at the same instant, the channel makes the goroutine that performs its respective send or receive operation first wait. Synchronization is inherent in the interaction between the send and receive on the channel. One can\u2019t happen without the other.</p>"},{"location":"go-study/07-concurrency/2-channel/channel/#buffered-channels","title":"Buffered Channels","text":"<p>A buffered channel is a channel with capacity to hold one or more values before they\u2019re received. These types of channels don\u2019t force goroutines to be ready at the same instant to perform sends and receives. There are also different conditions for when a send or receive does block. A receive will block only if there\u2019s no value in the channel to receive. A send will block only if there\u2019s no available buffer to place the value being sent. This leads to the one big difference between unbuffered and buffered channels: An unbuffered channel provides a guarantee that an exchange between two goroutines is performed at the instant the send and receive take place. A buffered channel has no such guarantee.</p>"},{"location":"go-study/07-concurrency/2-channel/channel/#select","title":"Select","text":"<p>Select statement provides another way to handle multiple channels.  * All channels are evaluated. * It blocks until one of its cases can run, then it executes that case.  * It chooses one at random if multiple are ready.</p> <pre><code>select {\ncase &lt;-ch1:\n    fmt.Println(\"ch1\")\ncase &lt;-ch2:\n    fmt.Println(\"ch2\")\ndefault:    \n    fmt.Println(\"default\")\n}\n</code></pre>"},{"location":"go-study/07-concurrency/2-channel/channel/#summary","title":"Summary","text":"<ul> <li>Concurrency is the independent execution of goroutines.</li> <li>Functions are created as goroutines with the keyword go.</li> <li>Goroutines are executed within the scope of a logical processor that owns a single operating system thread and run   queue.</li> <li>A race condition is when two or more goroutines attempt to access the same resource.</li> <li>Atomic functions and mutexes provide a way to protect against race conditions.</li> <li>Channels provide an intrinsic way to safely share data between two goroutines.</li> <li>Unbuffered channels provide a guarantee between an exchange of data. Buffered channels do not.</li> </ul>"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/","title":"Concurrency patterns","text":"<ul> <li>Concurrency Patterns</li> <li>A boring function</li> <li>Go Routines</li> <li>Channels<ul> <li>Synchronization</li> <li>Buffered Channel</li> </ul> </li> <li>Boring Channel</li> <li>Boring function that returns a receive channel</li> <li>Channels as a handle on a service</li> <li>Multiplexing</li> <li>Restoring Sequence</li> <li>Select Channel</li> <li>Fain-in (Multiplexing) again</li> <li>Timeout using Select</li> <li>Timeout for whole conversation using Select</li> <li>Quit channel</li> <li>Receive on Quit Channel</li> <li>Daisy-chain</li> <li>Systems Software</li> <li>Google Search: A fake framework</li> <li>Google Search 1.0</li> <li>Google Search 2.0</li> <li>Google Search 2.1</li> <li>Avoid Timeout</li> <li>Summary</li> <li>One advise:</li> <li>Conclusion</li> </ul>"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#concurrency-patterns","title":"Concurrency Patterns","text":"<ul> <li>Concurrency is the composition of independently executing processes.</li> <li>Concurrency is a way to structure software, particularly as a way to write clean code that interacts well with the real world.</li> <li> <p>Concurrency is not parallelism.</p> </li> <li> <p>Concurrency is not parallelism, although it enables parallelism.</p> </li> <li>If you have only one processor, your program can still be concurrent but it cannot be parallel.</li> <li>On the other hand, a well-written concurrent program might run efficiently in parallel on a multi-processors.</li> </ul>"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#a-boring-function","title":"A boring function","text":"<ol> <li>boring function is to print a message to the console and sleeps for a random amount of time in milliseconds.</li> <li> <p>main function spawn the boring function and waits for 2 seconds before exiting.</p> <p>boring function</p> </li> </ol>"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#go-routines","title":"Go Routines","text":"<ul> <li>It's an independently executing function, launched by a go statement.</li> <li>It has its own call stack, which grows and shrinks as required.</li> <li>It's very cheap.  It's practical to have thousands, even hundreds of thousands of goroutines.</li> <li>It's not a thread.</li> <li>There might be only one thread in a program with thousands of goroutines</li> </ul>"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#channels","title":"Channels","text":"<ul> <li>Think of a bucket chain</li> <li>3 components: sender, buffer, receiver</li> <li>The buffer is optional</li> <li>Channels are the pipes that connect concurrent goroutines.</li> <li>unbuffered channel is blocked when no data sent or received</li> </ul>"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#synchronization","title":"Synchronization","text":"<ul> <li>When the main function executes &lt;-c, it will wait for a value to be sent.</li> <li>Similarly, when the boring function executes c &lt;- value, it waits for a receiver to be ready.</li> <li>A sender and receiver must both be ready to play their part in the communication.  Otherwise, we wait until they are.</li> <li>Thus channels both communicate and synchronize.</li> </ul>"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#buffered-channel","title":"Buffered Channel","text":"<ul> <li>A buffered channel is a channel with a buffer. <pre><code>// buffered channel with a capacity of 10\nch := make(chan int, 10)\n</code></pre></li> <li>Buffering removes synchronization.</li> <li>Buffering makes them more like Erlang's mailboxes.</li> <li>Buffered channels can be important for some problems, but they are more subtle to reason about.</li> </ul>"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#boring-channel","title":"Boring Channel","text":"boring communication"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#boring-function-that-returns-a-receive-channel","title":"Boring function that returns a receive channel","text":"return a receive channel"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#channels-as-a-handle-on-a-service","title":"Channels as a handle on a service","text":"channel as a handle"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#multiplexing","title":"Multiplexing","text":"<p>These programs make Joe and Ann count in lockstep.  We can instead use a fan-in function to let whosoever is ready to talk. </p> multiplexing"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#restoring-sequence","title":"Restoring Sequence","text":"<ul> <li>Send a channel on a channel, making goroutine waits its turn.</li> <li>Receive all messages, then enable them again by sending on a private channel.</li> <li>First we define a message type that contains a channel for reply</li> </ul> <pre><code>type Message struct {\n    str string\n    wait chan bool\n}\n</code></pre> Restoring Sequence"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#select-channel","title":"Select Channel","text":"<ul> <li>A control structure unique to concurrency.</li> <li>The reason channels and goroutines are built into the language.</li> <li>The select statement provides another way to handle multiple channels.</li> <li>It's like a switch, but each case is a communication:</li> <li>All channels are evaluated.</li> <li>Selection blocks until one communication can proceed. which then does.</li> <li>If multiple can proceed, select chooses pseudo-randomly.</li> <li>A default clause, if present, executes immediately if no channel is ready.</li> </ul> <pre><code>select {\n    case &lt;-ch1:\n        fmt.Println(\"ch1\")\n    case &lt;-ch2:\n        fmt.Println(\"ch2\")\n    default:\n        fmt.Println(\"default\")\n}\n</code></pre>"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#fain-in-multiplexing-again","title":"Fain-in (Multiplexing) again","text":"<p>Rewrite our original fan-in function.  Only one goroutine is needed.</p> <p>Old implementation: <pre><code>func fanIn(input1, input2 &lt;- chan string) &lt;- chan string {\n    c := make(chan string)\n    go func() { for { c &lt;- &lt;-input1 } }()\n    go func() { for { c &lt;- &lt;- inputs2 } }()\n\n    return c\n}\n</code></pre> We can rewrite it using select statement. Only one goroutine is needed:</p> <pre><code>func fanIn(input1, input2 &lt;- chan string) &lt;- chan string {\n    c := make(chan string)\n    go func() {\n        for {\n            select {\n            case s := &lt;-input1:\n                c &lt;- s\n                case s := input2:\n                c &lt;- s\n            }           \n        }           \n    }\n}\n</code></pre> Fan-in using select"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#timeout-using-select","title":"Timeout using Select","text":"<p>The time.After function returns a channel that blocks for the specified duration.  After the duration, it sends the current time, once.</p> <p><pre><code>func main() {\n    c := boring9(\"Joe\")\n\n    for {\n        select {\n        case s := &lt;-c:\n            fmt.Println(s)\n        case &lt;-time.After(1 * time.Second):\n            fmt.Println(\"You're too slow.\")\n            return\n        }\n    }\n}\n</code></pre> |   |                                             | |---|---------------------------------------------| |   | timeout using select |</p>"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#timeout-for-whole-conversation-using-select","title":"Timeout for whole conversation using Select","text":"<p>Create the timer once, outside the loop, to time out the whole conversation. (In the previous program, we had a timeout for each message)</p> <p><pre><code>func main() {\n    c := boring10(\"Joe\")\n    timeout := time.After(5 * time.Second)\n\n    for {\n        select {\n        case s := &lt;-c:\n            fmt.Println(s)\n        case &lt;-timeout:\n            fmt.Println(\"You talk too much.\")\n            return\n        }\n    }\n}\n</code></pre> |   |                                              | |---|----------------------------------------------| |   | timeout using select |</p>"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#quit-channel","title":"Quit channel","text":"<p>We can turn this around and tell joe to stop when we're tired of listening to him. <pre><code>    quit := make(chan bool)\n    c := boring11(\"Joe\", quit)\n    for i := rand.Intn(10); i &gt;= 0; i-- {\n        fmt.Println(&lt;-c)\n    }\n    quit &lt;- true\n</code></pre></p> <p><pre><code>    select {\n    case c &lt;- fmt.Sprintf(\"%s %d\", msg, i):\n    // do nothing\n    case &lt;-quit:\n        return\n}\n</code></pre> |   |                                           | |---|-------------------------------------------| |   | Quit Channel |</p>"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#receive-on-quit-channel","title":"Receive on Quit Channel","text":"<p>How do we know it's finished?  Wait for it to tell us it's done: receive on the quit channel.</p> <pre><code>    quit := make(chan string)\n    c := boring12(\"Joe\", quit)\n    for i := rand.Intn(10); i &gt;= 0; i-- {\n    fmt.Println(&lt;-c)\n    }\n    quit &lt;- \"Bye!\"\n    fmt.Printf(\"Joe says: %q\\n\", &lt;-quit)\n</code></pre> <pre><code>        select {\n        case c &lt;- fmt.Sprintf(\"%s %d\", msg, i):\n            // do nothing\n        case &lt;-quit:\n            //cleanup()\n            quit &lt;- \"See you!\"\n            return\n        }\n</code></pre> Receive on Quit Channel"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#daisy-chain","title":"Daisy-chain","text":"Daisy Chain"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#systems-software","title":"Systems Software","text":"<p>Go was designed for writing systems software. Let's see how the concurrency features come into play.</p> <p>*Example: Google Search* Q: What does Google Search do?  A: Given a query, return a page of search results (and some ads)  Q: How do we get the search results?  A: Send the query to Web search, Image search, YouTube, Maps, News, etc., then mix the results</p> <p>How do we implement this?</p>"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#google-search-a-fake-framework","title":"Google Search: A fake framework","text":"<p>We can simulate the search function, much as we simulated conversation before.</p> <pre><code>var (\n    Web   = FakeSearch(\"web\")\n    Image = FakeSearch(\"image\")\n    Video = FakeSearch(\"video\")\n)\n\ntype Result string\ntype Search func(query string) Result\n\nfunc FakeSearch(kind string) Search {\n    return func(query string) Result {\n        time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)\n        return Result(fmt.Sprintf(\"%s result for %q\\n\", kind, query))\n    }\n}\n</code></pre>"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#google-search-10","title":"Google Search 1.0","text":"ggole search"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#google-search-20","title":"Google Search 2.0","text":"<p>Run the Web, Image, and Viideo searches concurrently, and wait for all results.  No locks. No condition variables.  No callbacks.</p> <pre><code>func Google20(query string) (results []Result) {\n    c := make(chan Result)\n    go func() { c &lt;- Web(query) }()\n    go func() { c &lt;- Image(query) }()\n    go func() { c &lt;- Video(query) }()\n\n    for i := 0; i &lt; 3; i++ {\n        result := &lt;-c\n        results = append(results, result)\n    }\n\n    return results\n}\n</code></pre> Google Search 2.0"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#google-search-21","title":"Google Search 2.1","text":"<p>Don't wait for slow servers. No locks. No condition variables. No callbacks.</p> <p><pre><code>func Google21(query string) (results []Result) {\n    c := make(chan Result)\n    go func() { c &lt;- Web(query) }()\n    go func() { c &lt;- Image(query) }()\n    go func() { c &lt;- Video(query) }()\n\n    timeout := time.After(80 * time.Millisecond)\n\n    for i := 0; i &lt; 3; i++ {\n        select {\n        case result := &lt;-c:\n            results = append(results, result)\n        case &lt;-timeout:\n            fmt.Println(\"time out\")\n            return\n        }\n    }\n\n    return results\n}\n</code></pre> |   |                                   | |---|-----------------------------------| |   | Google Search 2.1 |</p>"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#avoid-timeout","title":"Avoid Timeout","text":"<p>Q: How do we avoid discarding results from slow servers?  A: Replicate the servers.  Send requests to multiple replicas, and use the first response.</p> <pre><code>func First(query string, replicas ...Search) Result {\n    c := make(chan Result)\n    searchReplica := func(i int) { c &lt;- replicas[i](query) }\n\n    for i := range replicas {\n        go searchReplica(i)\n    }\n\n    return &lt;-c\n}\n</code></pre> using first function Google Search 3.0"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#summary","title":"Summary","text":"<p>In just a few simple transformations we used Go's concurrency primitives to convert a: - slow - sequential - failure-sensitive</p> <p>program into one that is:</p> <ul> <li>fast</li> <li>concurrent</li> <li>replicated</li> <li>robust</li> </ul> <p></p>"},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#one-advise","title":"One advise:","text":""},{"location":"go-study/07-concurrency/3-concurrency-patterns/concurrency-patterns/#conclusion","title":"Conclusion","text":"<p>Goroutines and channels make it easy to express complex operations dealing with: - multiple inputs - multiple outputs - timeouts - failure</p> <p>And they're fun to use.</p>"},{"location":"go-study/07-concurrency/4-advance-concurrency/advance-concurrency/","title":"Advance Concurrency","text":""},{"location":"go-study/07-concurrency/4-advance-concurrency/advance-concurrency/#recap","title":"Recap","text":"<p>Concurrency is built into the language rather than being a library.  Therefore, it's easy to deal with.</p>"},{"location":"go-study/07-concurrency/4-advance-concurrency/advance-concurrency/#goroutines-and-channels","title":"Goroutines and Channels","text":"<p>Goroutines are independently executing functions in the same address space. <pre><code>go f()\ngo g(1,2)\n</code></pre></p> <p>Channels are typed values that allow goroutines to synchronize and exchange information. <pre><code>c:= make(chan int)\ngo func() { c &lt;- 1 }()  // send 1 to c\nn := &lt;-c // receive from c\n</code></pre></p>"},{"location":"go-study/07-concurrency/4-advance-concurrency/advance-concurrency/#its-easy-to-go-but-how-to-stop","title":"It's easy to go, but how to stop?","text":"<ul> <li>Long-lived programs need to clean up</li> <li>Let's look at how to write programs that handle communication, periodic events, and cancellation.</li> <li>The core is Go's select statement: a switch for communication.</li> </ul> <pre><code>select {\ncase xc &lt;- x:\n    fmt.Println(\"send x to xc\")\ncase y := &lt;-yc:\n    fmt.Println(\"received y from yc\", y)        \n}\n</code></pre>"},{"location":"go-study/07-concurrency/effective-concurrency/01-goroutine/","title":"Go Concurrency","text":""},{"location":"go-study/07-concurrency/effective-concurrency/01-goroutine/#goroutines","title":"Goroutines","text":"<p>The go keyword starts the given function in a new goroutine. It is a lightweight threads.</p> <p>The number of operating system threads used by the Go runtime is equal to the number of processors/cores on the platform. You can change this by setting the GOMAXPROCS environment variable.</p>"},{"location":"go-study/07-concurrency/effective-concurrency/01-goroutine/#channels","title":"Channels","text":""},{"location":"go-study/07-concurrency/effective-concurrency/01-goroutine/#mutex","title":"Mutex","text":""},{"location":"go-study/07-concurrency/effective-concurrency/01-goroutine/#waitgroups","title":"WaitGroups","text":""},{"location":"go-study/07-concurrency/effective-concurrency/01-goroutine/#conditional-variables","title":"Conditional Variables","text":""},{"location":"go-study/07-concurrency/up-and-running/","title":"Up-and-Running-with-Concurrency-in-Go-Golang-","text":"<p>Up and Running with Concurrency in Go (Golang), by Packt Publishing</p>"},{"location":"go-study/07-concurrency/up-and-running/6-Waitgroups/wait-group/","title":"Using Waitgroup","text":"<p>Waitgroup syntax overview</p> <pre><code>var wg = sync.Waitgroup{}\nwg.Add(&lt;int&gt;)               // increase counter by int\nwg.Done()                   // decrement counter\nwg.Wait()                   // BLOCKING - waiting other goroutines to finish or wg decrement to zero then it continues\n</code></pre>"},{"location":"go-study/07-concurrency/up-and-running/7-Channels/channel/","title":"Using Channels","text":"<ul> <li>Channels are used to pass data between / synchronize goroutines, including func main</li> <li>Go philosophy:<ul> <li>\"Don't communicate by sharing memory, share memory by communicating.\"</li> </ul> </li> </ul>"},{"location":"go-study/07-concurrency/up-and-running/7-Channels/channel/#channel-syntax-overview","title":"Channel Syntax Overview","text":"<pre><code>ch := make(chan string)\nch &lt;- myData            // (NO BLOCKING)\nch &lt;- myData2           // (BLOCKING) wait until datum in the channel is pulled\nmyVar &lt;- ch             // (BLOCKING)\n\nclose(ch)               // optional - no data can't be sent to this channel\n</code></pre>"},{"location":"rust-study/","title":"Rust Courses","text":"Topics 1 Installation and Setup 2 Quick Start 3 Programming Concepts Variable and Mutability q Ownership Structuring Rust Code Enum and Pattern Matching Modules"},{"location":"rust-study/01-rust-setup/faster-linking/","title":"zld","text":"<p>A faster version Apple's <code>ld</code> linker is <code>zld</code>. It is a drop-in replacement for <code>ld</code> and <code>ld64</code>. It is faster than <code>ld</code> and <code>ld64</code> because it is written in Rust. It is available on Homebrew.</p> <p>.cargo/config.toml</p> <pre><code># On Windows\n# cargo install -f cargo-binutils\n# rustup component add llvm-tools-preview\n[target.x86_64-pc-windows-msvc]\nrustflags = [\"-C\", \"link-arg=-fuse-ld=lld\"]\n\n[target.x86_64-pc-windows-gnu]\nrustflags = [\"-C\", \"link-arg=-fuse-ld=lld\"]\n\n# On Linux:\n# - Ubuntu, `sudo apt-get install lld clang`\n# - Arch, `sudo pacman -S lld clang`\n[target.x86_64-unknown-linux-gnu]\nrustflags = [\"-C\", \"linker=clang\", \"-C\", \"link-arg=-fuse-ld=lld\"]\n\n# On MacOS, `brew install michaeleisel/zld/zld`\n[target.x86_64-apple-darwin]\nrustflags = [\"-C\", \"link-arg=-fuse-ld=/usr/local/bin/zld\"]\n[target.aarch64-apple-darwin]\nrustflags = [\"-C\", \"link-arg=-fuse-ld=/usr/local/bin/zld\"]\n</code></pre>"},{"location":"rust-study/01-rust-setup/setup-rust-env/","title":"Setup Rust Env on MacOs","text":""},{"location":"rust-study/01-rust-setup/setup-rust-env/#rust-language","title":"Rust Language","text":""},{"location":"rust-study/01-rust-setup/setup-rust-env/#install-rust","title":"Install Rust","text":"<ol> <li>Installation: curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</li> <li>Installation includes rustc, cargo, rustup     cargo - like maven or gradle in java and go mod in golang    rustc - rust compiler    rustup - toolchain multiplexer to enable you to switch compiler versions</li> <li>Verify: rustc --version</li> <li>Upgrade Rust: rustup update</li> <li>Uninstall Rust: rustup self uninstall</li> </ol>"},{"location":"rust-study/01-rust-setup/setup-rust-env/#switching-rust-toolchains","title":"Switching Rust toolchains","text":"<p>Show what toolchains installed on the machine</p> <pre><code>rustup --help\nrustup show\n</code></pre> <p>default - Set the default toolchain</p> <p>override - Modify directory toolchain overrides</p> <pre><code>rustup override set nightly/stable\n</code></pre> <pre><code>rustup default nightly/stable/version\n</code></pre>"},{"location":"rust-study/02-quick-start/quick-start/","title":"Generating a New Project","text":"<p>cargo new hello-rust</p> <p>new directory called hello-rust with the following files:</p> <pre><code>hello-rust\n|- Cargo.toml\n|- src\n  |- main.rs\n</code></pre>"},{"location":"rust-study/02-quick-start/quick-start/#a-small-rust-application","title":"A small Rust application","text":"<p>Now let\u2019s write a small application with our new dependency. In our main.rs, add the following code:</p> <pre><code>use ferris_says::say;\n// from the previous step\nuse std::io::{stdout, BufWriter};\n\nfn main() {\n    let stdout = stdout();\n    let message = String::from(\"Hello fellow Rustaceans!\");\n    let width = message.chars().count();\n\n    let mut writer = BufWriter::new(stdout.lock());\n    say(message.as_bytes(), width, &amp;mut writer).unwrap();\n}\n</code></pre> <p>cargo run</p> <pre><code>----------------------------\n&lt; Hello fellow Rustaceans! &gt;\n----------------------------\n              \\\n               \\\n                 _~^~^~_\n             \\) /  o o  \\ (/\n               '_   -   _'\n               / '-----' \\\n</code></pre> <p>Rust Language link!</p> <p>Style Guidelines</p>"},{"location":"rust-study/02-quick-start/quick-start/#run-example-and-bin-executable-rust","title":"Run example and bin executable rust","text":"<p>Run example applications</p> <ol> <li>create examples directory at same level of src directory</li> <li>create any file name contains main function</li> <li>cargo run --example file_name</li> </ol> <pre><code>cargo run --example file_name\n</code></pre> <p>Run bin applications</p> <ol> <li>create bin directory within src directory</li> <li>create any file name contains main function</li> <li>cargo run --bin file_name</li> </ol> <pre><code>cargo run --bin file_name\n</code></pre>"},{"location":"rust-study/03-programming-concepts/1-variable-and-mutability/","title":"Variable &amp; Data Type","text":"<p>Rust has several signed integer types of known size:</p> <ul> <li>i8</li> <li>i16</li> <li>i32</li> <li>i64</li> <li>i128</li> </ul> <p>unsigned integer types of know size:</p> <ul> <li>u8</li> <li>u16</li> <li>u32</li> <li>u64</li> <li>u128</li> </ul> <p>Rust has platform-specific integer types</p> <ul> <li>isize</li> <li>usize</li> </ul> <p>these types are optimized for the natural word size of your platform</p> <ul> <li>for maximum efficiency</li> </ul>"},{"location":"rust-study/03-programming-concepts/1-variable-and-mutability/#rust-naming-convention","title":"Rust naming convention","text":"<p>For details click here</p> <p>In general, Rust tends to use UpperCamelCase for \"type-level\" constructs (types and traits) and snake_case for \" value-level\" constructs. More precisely:</p> Item Convention Crates unclear Modules snake_case Types UpperCamelCase Traits UpperCamelCase Enum variants UpperCamelCase Functions snake_case Methods snake_case General constructors new or with_more_details Conversion constructors from_some_other_type Macros snake_case Local variables snake_case Statics SCREAMING_SNAKE_CASE Constants SCREAMING_SNAKE_CASE Type parameters concise UpperCamelCase, usually single uppercase letter: T Lifetimes short lowercase, usually a single letter: 'a, 'de, 'src Features unclear but see C-FEATURE <p>In Rust Language, by default variables are immutable. This is one of many nudges in Rust that encourages you to write your code in a way that takes advantage of the safety and easy concurrency that Rust offers. However, you can still make your variables mutable. Let\u2019s explore how and why Rust encourages you to favor immutability, and why you might want to opt out.</p> <pre><code>fn main() {\n    let x = 5;\n    println!(\"The value of x is: {}\", x);\n    x = 6;\n    println!(\"The value of x is: {}\", x);\n}\n</code></pre> <p>x variable can not re-assign.</p> <p>Immutable variable can not be reassigned, but it can be re-declare or called shadowing.</p> <pre><code>fn main() {\n    let num = \"12345\";\n    println!(\"The value of x is: {}\", num);\n    let num = 12345;\n    println!(\"The value of x is: {}\", num);\n}\n</code></pre> <p>But mutability can be very useful. Variables are immutable only by default; we can make them mutable by adding mut in front of the variable name.</p> <pre><code>fn main() {\n    let mut x = 5;\n    println!(\"The value of x is: {}\", x);\n    x = 6;\n    println!(\"The value of x is: {}\", x);\n}\n</code></pre>"},{"location":"rust-study/03-programming-concepts/1-variable-and-mutability/#constants","title":"Constants","text":"<p>Here\u2019s an example of a constant declaration where the constant\u2019s name is MAX_POINTS and its value is set to 100,000. Rust constant naming convention is to use all upper case with underscores between words. Compiler will give warning and suggest to upper case. The underscore in the integer value is for eligible purpose such as in English 100,000 is more eligible than 100000 which most computer languages lack.</p> <pre><code>    const MAX_POINTS: u32 = 100_000;\n</code></pre>"},{"location":"rust-study/03-programming-concepts/1-variable-and-mutability/#shadowing","title":"Shadowing","text":"<p>we can declare a new variable with the same name as a previous variable, and the new variable shadows the previous variable. Rustaceans say that the first variable is shadowed by the second, which means that the second variable\u2019s value is what we\u2019ll see when we use the variable. We can shadow a variable by using the same variable\u2019s name and repeating the use of the let keyword as follows:</p> <pre><code>fn main() {\n    let x = 5;\n    let x = x + 1;\n    let x = x * 2;\n\n    println!(\"The value of x is: {}\", x);\n}\n</code></pre> <pre><code>The value of x is: 12\n</code></pre> <p>The other difference between mut and shadowing is that because we\u2019re effectively creating a new variable when we use the let keyword again, we can change the type of the value, but reuse the same name. For example, say our program asks a user to show how many spaces they want between some text by inputting space characters, but we really want to store that input as a number:</p> <pre><code>fn main() {\n    let spaces = \"   \";\n    let spaces = spaces.len();\n}\n</code></pre> <p>However, if we try to use mut for this, as shown here, we\u2019ll get a compile-time error:</p> <pre><code>let mut spaces = \"   \";\nspaces = spaces.len();\n</code></pre> <p>The error says we\u2019re not allowed to mutate a variable\u2019s type:</p> <pre><code>error[E0308]: mismatched types\n--&gt; src/main.rs:3:14\n|\n3 |     spaces = spaces.len();\n|              ^^^^^^^^^^^^ expected &amp;str, found usize\n|\n= note: expected type `&amp;str`\nfound type `usize`\n</code></pre>"},{"location":"rust-study/03-programming-concepts/2-data-types/","title":"Data Type","text":""},{"location":"rust-study/03-programming-concepts/2-data-types/#scalar-types","title":"Scalar Types","text":"<p>A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters.</p>"},{"location":"rust-study/03-programming-concepts/2-data-types/#integer-types","title":"Integer Types","text":"Length Signed Unsigned 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize"},{"location":"rust-study/03-programming-concepts/2-data-types/#floating-point-types","title":"Floating Point Types","text":"Length Signed 32-bit f32 64-bit f64"},{"location":"rust-study/03-programming-concepts/2-data-types/#numeric-operations","title":"Numeric Operations","text":"<pre><code>fn main() {\n    // addition\n    let sum = 5 + 10;\n\n    // subtraction\n    let difference = 95.5 - 4.3;\n\n    // multiplication\n    let product = 4 * 30;\n\n    // division\n    let quotient = 56.7 / 32.2;\n\n    // remainder\n    let remainder = 43 % 5;\n}\n</code></pre>"},{"location":"rust-study/03-programming-concepts/2-data-types/#character-type","title":"Character Type","text":"<pre><code>fn main() {\n   let c = 'z';\n   let z = '\u2124';\n   let heart_eyed_cat = '\ud83d\ude3b';\n}\n</code></pre>"},{"location":"rust-study/03-programming-concepts/2-data-types/#compound-types","title":"Compound Types","text":""},{"location":"rust-study/03-programming-concepts/2-data-types/#tuple","title":"Tuple","text":"<p>Grouping Values into Tuples A tuple is a general way of grouping together some number of other values with a variety of types into one compound type.</p> <pre><code>fn main() {\n    let tup: (i32, f64, u8) = (500, 6.4, 1);\n}\n</code></pre> <pre><code>fn main() {\n    let tup = (500, 6.4, 1);\n    let (x, y, z) = tup;\n\n    println!(\"The value of y is: {}\", y);\n}\n</code></pre> <pre><code>The value of y is: 6.4\n</code></pre> <p>In addition to destructuring through pattern matching, we can also access a tuple element directly by using a period (.) followed by the index of the value we want to access. For example:</p> <pre><code>fn main() {\n    let x: (i32, f64, u8) = (500, 6.4, 1);\n    let five_hundred = x.0;\n    let six_point_four = x.1;\n\n    let one = x.2;\n}\n</code></pre>"},{"location":"rust-study/03-programming-concepts/2-data-types/#arrays","title":"Arrays","text":"<p>Another way to have a collection of multiple values is with an array. Unlike a tuple, every element of an array must-have the same type. Arrays in Rust are different than arrays in some other languages because arrays in Rust have a fixed length: once declared, they cannot grow or shrink in size.</p> <pre><code>fn main() {\n    let a = [1, 2, 3, 4, 5];\n\n    let first = a[0];\n    let second = a[1];\n}\n</code></pre>"},{"location":"rust-study/03-programming-concepts/3-flow-controls/","title":"Flow Controls","text":""},{"location":"rust-study/03-programming-concepts/3-flow-controls/#if-test","title":"if-test","text":"<p>The parentheses around if test is not required. Will get compile warming if present. Must have curly brackets to enclose statement(s).</p> <pre><code>fn main() {\n    let height = 1.67;\n\n    if height &gt; 1.8 {\n        println!(\"You are tall\");\n    }\n}\n</code></pre>"},{"location":"rust-study/03-programming-concepts/3-flow-controls/#if-else-test","title":"if-else-test","text":"<pre><code>fn main() {\n    let height = 1.67;\n\n    if height &gt; 1.8 {\n        println!(\"You are tall\");\n    } else {\n        println!(\"You are not so tall\");\n    }\n}\n</code></pre> <p>Writing an if-else expression</p> <pre><code>fn main() {\n    let greet = \"Hola\";\n    let spoken_language = if greet == \"Hola\" { \"Spanish\" } else { \"Not Spanish\" };\n\n    println!(\"Language is {}\", spokenLanguage);\n}\n</code></pre>"},{"location":"rust-study/03-programming-concepts/3-flow-controls/#matching","title":"Matching","text":"<p>Rust has a match keyword, which you can to match:</p> <ul> <li>integers</li> <li>Booleans</li> <li>Enums</li> <li>Arrays</li> <li>Tuples</li> <li>Structs</li> </ul> <p>Match requires \"_\" for default</p> <p>Range</p> <pre><code>fn main() {\n    let num = 75;\n\n    match num {\n        0..=50 =&gt; println!(\"from 0-50\"),\n        51..=100 =&gt; println!(\"from 51 - 100\"),\n        _ =&gt; println!(\"No matching\")\n    }\n}\n</code></pre> <p>Specify multiple patterns using the | syntax</p> <pre><code>fn main() {\n    let num = 75;\n\n    match num {\n        25 | 50 =&gt; println!(\"25, or 50\"),\n        75 | 100 =&gt; println!(\"75 or100\"),\n        _ =&gt; println!(\"No matching\")\n    }\n}\n</code></pre> <p>infinity loop</p> <pre><code>fn main() {\n    loop {}\n}\n</code></pre>"},{"location":"rust-study/03-programming-concepts/3-flow-controls/#using-break-and-continue","title":"Using break and continue","text":"<pre><code>fn main() {\n    let some_condition = true;\n    loop {\n        if some_condition {\n            break;\n        }\n    }\n}\n</code></pre> <p>Continue</p> <pre><code>fn main() {\n    let some_condition = true;\n    loop {\n        if some_condition {\n            continue;\n        }\n    }\n}\n</code></pre>"},{"location":"rust-study/03-programming-concepts/3-flow-controls/#controlling-nested-loops","title":"Controlling Nested Loops","text":"<p>Label the out loop For example</p> <p>outer: loop</p> <p>break out of the outer loop</p> <p>break out</p>"},{"location":"rust-study/03-programming-concepts/4-collections/","title":"Compound Types snd Collections","text":""},{"location":"rust-study/03-programming-concepts/4-collections/#arrays","title":"Arrays","text":"<p>Array techniques</p> <pre><code>fn demo_arrays() {\n    println!(\"Using arrays\");\n\n    // You can create an array using simple literal syntax.\n    let a1 = [100, 101, 102];\n    println!(\"a1 length is {}, first element is {}\", a1.len(), a1[0]);\n\n    // You can also create a mutable array - you can change items, but you can't change the size.\n    let mut a2 = [100, 101, 102];\n    a2[0] = 999;\n    println!(\"a2 length is {}, first element is {}\", a2.len(), a2[0]);\n\n    // You can iterate over the elements in an array.\n    println!(\"Elements in a2:\");\n    for elem in a2 {\n        println!(\"  {}\", elem);\n    }\n}\n\nfn demo_arrays_techniques() {\n    println!(\"\\nArray techniques\");\n\n    // You can specify type info and size.\n    let a1: [i64; 5];\n    a1 = [100, 101, 102, 103, 104];\n    println!(\"a1 is {:?}\", a1);\n\n    // You can fill an array with [filler;size] syntax. \n    let mut a2 = [99; 5];\n    a2[0] = 58;\n    a2[4] = 25;\n\n    // You can display an array all at once, via the debug formatter.\n    println!(\"a2 is {:?}\", a2);\n}\n</code></pre>"},{"location":"rust-study/03-programming-concepts/4-collections/#tuples","title":"Tuples","text":"<p>A tuple is a fixed-size heterogeneous collection = literal syntax (a, b, c).</p> <p>using tup.index to access the element</p> <p>Rust does bounds-checking at compile time</p> <pre><code>fn demo_tuples() {\n    println!(\"\\nUsing tuples\");\n\n    // A tuple is a fixed-size heterogeneous collection.\n    let t1 = (9, \"h1\", 3.5);\n    println!(\"t1 elements are {}, {}, {}\", t1.0, t1.1, t1.2);\n\n    // You can also create a mutable tuple (you have to be consistent with element types).\n    let mut t2 = (9, \"hi\", 3.5);\n    t2.0 = 99;\n    println!(\"t2 elements are {}, {}, {}\", t2.0, t2.1, t2.2);\n\n    // You can create an empty tuple (handy for functions that return nothing at all).\n    let t3 = ();\n    println!(\"t3 is {:?}\", t3);\n\n    // You can specify type info.\n    let t4: (i32, bool, f64);\n    t4 = (58, true, 1.67);\n    println!(\"t4 is {:?}, elements are {} {} {}\", t4, t4.0, t4.1, t4.2);\n}\n</code></pre>"},{"location":"rust-study/03-programming-concepts/4-collections/#vectors","title":"Vectors","text":"<p>Vet is a generic, sequential, resizable collection and part of standard library - std::vec <pre><code>fn main() {\n    let mut v: Vec&lt;i32&gt; = Vec::new();\n    //or\n    let mut v = Vec::&lt;i32&gt;::new();\n\n    // create a Vec and initialize it via vec!\n    let mut v = vec![100, 101, 102];\n}\n</code></pre> <pre><code>fn demo_vectors() {\n    println!(\"\\nUsing vectors\");\n\n    // You can create a vector object using either of the following syntaxes.\n    let mut _v1: Vec&lt;i32&gt; = Vec::new();\n    let mut _v2 = Vec::&lt;i32&gt;::new();\n\n    // You can create a vector object and initialize it via the vec! macro.\n    let mut v3 = vec![100, 101, 102];\n\n    // Index into a vector (will panic if index is out-of-bounds).\n    let item = v3[0];\n    println!(\"Value: {}\", item);\n\n    // Index into a vector safely, returns an Option&lt;T&gt;. \n    let opt = v3.get(0);\n    match opt {\n        Some(value) =&gt; println!(\"Value: {}\", value),\n        None =&gt; println!(\"No value\")\n    }\n\n    // Add and remove items in a vector.\n    v3.push(103);\n    v3.push(104);\n    v3.push(105);\n    v3.pop();\n    v3.insert(0, 99);\n\n    // Iterate over items in a vector.\n    println!(\"Items in v3:\");\n    for item in &amp;v3 {\n        println!(\"  {}\", item)\n    }\n\n    // Display a vector all at once, via the debug formatter.\n    println!(\"v3 is {:?}\", v3);\n}\n</code></pre>"},{"location":"rust-study/03-programming-concepts/4-collections/#maps","title":"Maps","text":"<pre><code>fn demo_maps() {\n    println!(\"\\nUsing maps\");\n\n    // You can create a map object using either of the following syntax.\n    let mut m: HashMap&lt;String, i32&gt; = HashMap::new();\n    let mut _m2 = HashMap::&lt;String, i32&gt;::new();\n\n    // Insert items.\n    m.insert(String::from(\"UK\"), 44);\n    m.insert(String::from(\"NO\"), 47);\n    m.insert(String::from(\"SG\"), 65);\n\n    // Insert item, only if key is missing.\n    m.entry(String::from(\"SA\")).or_insert(27);\n\n    // Look-up a key (will panic if key is missing).\n    let val = m[\"UK\"];\n    println!(\"Value: {}\", val);\n\n    // Look up a key safely, returns an Option&lt;V&gt;.\n    let opt = m.get(\"UK\");\n    match opt {\n        Some(value) =&gt; println!(\"Value: {}\", value),\n        None =&gt; println!(\"No value\")\n    }\n\n    // Iterate over entries in a map.\n    println!(\"Entries in m:\");\n    for entry in &amp;m {\n        println!(\"  {:?}\", entry)\n    }\n\n    // Display a map all at once, via the debug formatter.\n    println!(\"m is {:?}\", m);\n}\n</code></pre>"},{"location":"rust-study/04-ownership/1-ownership/","title":"Ownership &amp; Borrowing","text":"<p>Three models of memory management, manual, garbage collection, and ownership &amp; borrowing.</p> Memory Management Model Language Manual C++ Garbage Collection Go, Java, C# Ownership &amp; Borrowing Rust"},{"location":"rust-study/04-ownership/1-ownership/#comparison-memory-management-models","title":"Comparison: Memory Management Models","text":""},{"location":"rust-study/04-ownership/1-ownership/#memory-unsafe","title":"Memory Unsafe","text":"<ul> <li>Segmentation faults</li> <li>Buffer overruns</li> <li>Dangling pointers</li> <li>Double-frees</li> </ul>"},{"location":"rust-study/04-ownership/1-ownership/#garbage-collection","title":"Garbage Collection","text":"<ul> <li>Does solve the memory</li> </ul>"},{"location":"rust-study/04-ownership/1-ownership/#borrowing","title":"Borrowing","text":"<ul> <li>local scope</li> <li>static global scope</li> <li>static mutable variable</li> <li>Strings in Rust</li> <li>copying vs. moving</li> <li>cloning</li> </ul> <p>Memory management in Rust is different to most other languages Need to consider:</p> <ul> <li>what is the scope of a variable</li> <li>why is memory allocated? heap or stack</li> <li>what does ownership mean in Rust</li> </ul> <p>When you define a variable in a function:</p> <ul> <li>the variable has local scope</li> <li>the variable goes out of scope at the closing '}'</li> <li> <p>variable memory allocated in the stack or heap depends on fixed or variable size</p> </li> <li> <p>Variables with a known, fixed size will be allocated on the stack.</p> </li> <li>Variables with an unknown size at compile time or a size that might change must be allocated on the heap.</li> </ul> <p>Languages with Garbage Collectors e.g. Java, Go, C#, will often abstract away complexities of the Stack and the Heap.</p> <p></p> <p>Ownership is a set of rules that govern how a Rust program manages memory. It helps ensure the memory safety of your program without a garbage collector.,p/&gt;</p>"},{"location":"rust-study/04-ownership/1-ownership/#rules-of-ownership","title":"Rules of Ownership","text":"<ul> <li>Each value in Rust has a variable called its owner.</li> <li>There can only be one owner at a time.</li> <li>When the owner goes out of scope, the value will be dropped.   The two pillars of Rust are Speed and Safety. Rust has a borrower checker to enforce these rules at compile time.</li> </ul> <p>When you define a variable in a block</p> <ul> <li>the variable has block scope</li> <li>the variable goes out of scope at the closing '}'</li> </ul>"},{"location":"rust-study/04-ownership/1-ownership/#copyable-data-types","title":"Copyable Data Types","text":"<ul> <li>primitive types (scalar &amp; compound)</li> <li>known, fixed-size types at compile time</li> <li>stored on the stack</li> <li>implement the Copy trait</li> </ul>"},{"location":"rust-study/04-ownership/1-ownership/#copy-trait","title":"Copy Trait","text":"<p>Primitive types implement the Copy trait. When you assign a value to another variable, it bit-copies the value. The original variable is still valid. </p>"},{"location":"rust-study/04-ownership/1-ownership/#move-semantics","title":"Move Semantics","text":"<p>Other types don't implement the Copy trait. When you assign a value to another variable, it moves the value. </p> <p>Possible to allocate memory elsewhere in Rust:</p> <ul> <li>static storage</li> <li>heap-based storage</li> </ul> <pre><code>pub fn do_it() {\n    println!(\"\\nIn demo_locals::do_it()\");\n\n    let x = 42; // local scope\n\n    if x != 0 {\n        let s1 = \"Andy\";  // black scope\n        println!(\"s1: {}\", s1);\n    }\n\n    // Nope:\n    // println!(\"s1 {}\", s1); // compile error because s1 is out of scope\n}\n</code></pre>"},{"location":"rust-study/04-ownership/1-ownership/#static-local-scope","title":"static local scope","text":"<ul> <li>a static variable is allocated permanently</li> <li>it exists until the program terminates</li> </ul> <p>you can define static variables:</p> <ul> <li>Locally, inside a function</li> <li>Globally, outside a function</li> </ul> <pre><code>use once_cell::sync::Lazy;\n// Defined in the once_cell crate.\nuse chrono::{DateTime, Utc}; // Defined in the chrono crate. \n\nuse std::thread::sleep;\nuse std::time::Duration;\n\npub fn do_it() {\n    println!(\"\\nIn demo_static_local::do_it()\");\n\n    static_init_at_compile_time();\n    static_init_at_run_time();\n}\n\nfn static_init_at_compile_time() {\n    static MESSAGE: &amp;str = \"Croeso o Gymru \ud83d\ude03\";\n    println!(\"MESSAGE: {}\", MESSAGE);\n}\n\nfn static_init_at_run_time() {\n\n    // This statement won't work. \n    // You can't initialize a static directly with a run-time value (it's not thread-safe).\n    // static TIMESTAMP_WONT_WORK: DateTime&lt;Utc&gt; = Utc::now();\n\n    println!(\"Curr time: {}\", Utc::now().format(\"%T\"));\n\n    static TIMESTAMP: Lazy&lt;DateTime&lt;Utc&gt;&gt; = Lazy::new(|| {\n        sleep(Duration::new(5, 0));\n        let now = Utc::now();\n        println!(\"Curr time: {}\", now.format(\"%T\"));\n        return now;\n    });\n    println!(\"TIMESTAMP: {}\", (*TIMESTAMP).format(\"%T\"));\n}\n</code></pre>"},{"location":"rust-study/04-ownership/1-ownership/#copy-vs-clone","title":"Copy vs Clone","text":"<p>In Rust, bit-wise copying can copy only primitive types or struct containing primitive types. The variables are unknown &amp; not-fixed size can be cloned, and clone() is a method that creates a deep copy of the data.</p> <p>For example, the Person struct can be cloned, because it contains String, which is a heap-allocated type.</p> <pre><code>#[derive(Clone)]\nstruct Person {\n    name: String,\n    age: u8,\n}\n</code></pre> <p>For example the Person struct can be copied, because it contains only primitive types.</p> <pre><code>#[derive(Copy, Clone)]\nstruct Person {\n    id: u32,\n    age: u8,\n}\n</code></pre>"},{"location":"rust-study/04-ownership/1-ownership/#string-handler","title":"String Handler","text":"<pre><code>pub fn do_it() {\n    println!(\"\\nIn demo_string_handling::do_it()\");\n\n    using_string_literals();\n    using_string_objects();\n    using_mutable_string_objects();\n}\n\nfn using_string_literals() {\n    let s1 = \"hello\";\n    let s2: &amp;'static str = \"world\";\n\n    println!(\"s1: {}, ptr: {:p}, len: {} \", s1, s1.as_ptr(), s1.len());\n    println!(\"s2: {}, ptr: {:p}, len: {} \", s2, s2.as_ptr(), s2.len());\n}\n\nfn using_string_objects() {\n    let s3 = String::from(\"wales\");\n    let s4: String = String::from(\"cymru\");\n\n    println!(\"s3: {}, ptr: {:p}, len: {}\", s3, s3.as_ptr(), s3.len());\n    println!(\"s4: {}, ptr: {:p}, len: {}\", s4, s4.as_ptr(), s4.len());\n}   // String objects go out of scope here, so drop() is called on the Strings objects (because String implements the Drop trait).\n\nfn using_mutable_string_objects() {\n    let mut s5 = String::from(\"   super\");\n    s5.push_str(\" swans!   \");\n\n    let s6 = s5.trim().to_uppercase();\n\n    println!(\"s5: {}, ptr: {:p}, len: {}\", s5, s5.as_ptr(), s5.len());\n    println!(\"s6: {}, ptr: {:p}, len: {}\", s6, s6.as_ptr(), s6.len());\n} \n</code></pre>"},{"location":"rust-study/04-ownership/1-ownership/#copy-vs-moving-demo","title":"Copy vs Moving Demo","text":"<pre><code>pub fn do_it() {\n    println!(\"\\nIn demo_copying_vs_moving::do_it()\");\n\n    // Simple types implement the Copy trait. \n    // When you assign, it bit-copies the value.\n    let a = 42;\n    let b = a;\n    println!(\"a: {}, b: {}\", a, b);\n\n    // Other types don't implement the Copy trait. \n    // When you assign, it moves the value (i.e. transfers ownership). \n    // The original variable is invalidated.\n    let s1 = String::from(\"hello\");\n    let s2 = s1;\n\n    // Nope! Can't use s1 because its value has been moved into s2.\n    // println!(\"s1: {}\", s1);\n\n    // This is ok.\n    println!(\"s2: {}\", s2);\n}  \n</code></pre>"},{"location":"rust-study/04-ownership/1-ownership/#cloning-demo","title":"Cloning Demo","text":"<pre><code>pub fn do_it() {\n    println!(\"\\nIn demo_cloning::do_it()\");\n\n    // Simple types implement the Copy trait\n    let a = 42;\n    let b = a;\n    println!(\"a: {}, b: {}\", a, b);\n\n    // Other types don't implement the Copy trait.\n    // If you do want to copy without invalidating the original, call clone().\n    let mut s1 = String::from(\"hello\");\n    let s2 = s1.clone();\n\n    s1.push_str(\" world, det er istid eller kaffetid snart\");\n    println!(\"s1: {}\", s1);\n    println!(\"s2: {}\", s2);\n}\n</code></pre>"},{"location":"rust-study/04-ownership/2-borrow/","title":"Borrowing","text":"<ul> <li>Simple borrowing</li> <li>Rust borrow checker</li> <li>String slice techniques</li> <li>Array slices</li> <li>Array slices techniques</li> </ul>"},{"location":"rust-study/04-ownership/2-borrow/#simple-borrowing","title":"Simple borrowing","text":"<p>Instead of transferring/moving ownership by assign one variable to another. ie let a = b assumption that a does not have Copy trait. Rust has feature called borrow.</p> <ul> <li>Facilitated via references</li> <li>A reference can borrow a value, without claiming ownership</li> <li>To borrow a value by prefix the value with &amp;</li> <li>A value can be immutably borrowed any number of times</li> <li>Borrowed values are immutable</li> <li>Even if the borrowed value is mutable, that borrow can't be used to mutate the value</li> </ul> <pre><code>fn main() {\n    let s = String::from(\"huey\");\n    let r = &amp;s; // r borrows value from s\n    // another way to borrow, multiple immutable borrowers is OK.\n    let q: &amp;String = &amp;s;\n\n    println!(\"{}, {}, {}\", s, r, q);\n}\n</code></pre>"},{"location":"rust-study/04-ownership/2-borrow/#mutable-borrower","title":"Mutable borrower","text":"<ul> <li>Mutable borrows allow values to be changed without transferring ownership</li> <li>Only one mutable borrow can exist at once</li> </ul> <pre><code>fn main() {\n    let mut s = String::from(\"dewey\");\n    let b = &amp;mut a;\n\n    // Not allow multiple mutable borrowers because of race conditions. \n    //let c = &amp;mut a;\n}\n</code></pre>"},{"location":"rust-study/04-ownership/2-borrow/#borrow-checker-rules","title":"Borrow Checker / Rules","text":"<p>The borrow checker enforces these rules:</p> <ul> <li>Single writer (mutable borrow)</li> <li>Many readers (immutable borrow)</li> <li>No mixing of mutable and immutable borrows to prevent data races</li> </ul> <pre><code>pub fn do_it() {\n    println!(\"\\nIn demo_borrow_checker::do_it()\");\n\n    defining_many_immutable_references();\n    restrictions_after_defining_mutable_reference();\n    restrictions_after_defining_immutable_reference();\n}\n\nfn defining_many_immutable_references() {\n    let s = String::from(\"hello\");\n\n    // You can define any number of immutable borrows.\n    let r1 = &amp;s;\n    let r2 = &amp;s;\n    let r3 = &amp;s;\n\n    println!(\"r1: {}, r2: {}, r3: {}\", r1, r2, r3);\n}\n\nfn restrictions_after_defining_mutable_reference() {\n    let mut s = String::from(\"huey\");\n    s.push_str(\" louie\");\n\n    // If you have a mutable borrow...\n    let r1 = &amp;mut s;\n\n    // Then you can't have any other borrows at all.\n    // let r2 = &amp;mut s;       // Nope!\n    // let r3 = &amp;s;           // Nope!\n\n    // And you can't do this either (println! tries to borrow s).\n    // println!(\"s: {}\", s);  // Nope!\n\n    r1.push_str(\" dewey\");\n\n    println!(\"r1: {}\", r1);\n}\n\nfn restrictions_after_defining_immutable_reference() {\n    let mut s = String::from(\"huey\");\n    s.push_str(\" louie\");\n\n    // If you have immutable borrow(s)...\n    let r1 = &amp;s;\n    let r2 = &amp;s;\n\n    // Then you can't have any mutable borrows.\n    // let r3 = &amp;mut s;       // Nope!\n\n    // And you also can't modify the original object either.\n    // s.push_str(\" dewey\");  // Nope!\n\n    println!(\"s: {}, r1: {}, r2: {}\", s, r1, r2);\n}\n</code></pre>"},{"location":"rust-study/04-ownership/2-borrow/#string-slice-intro","title":"String Slice Intro","text":"<pre><code>pub fn do_it() {\n    println!(\"\\nIn demo_string_slice_intro::do_it()\");\n\n    slice_string_object();\n    slice_string_literal();\n}\n\nfn slice_string_object() {\n    let obj = String::from(\"hello\");\n\n    // Define a &amp;String variable (implicitly typed).\n    let s1 = &amp;obj;\n\n    // Define a &amp;str variable (explicitly typed).\n    let s2: &amp;str = &amp;obj;\n\n    println!(\"s1: {}, s2: {}\", s1, s2);\n}\n\nfn slice_string_literal() {\n\n    // Define a &amp;str variable (implicitly typed).\n    let s3 = \"hello\";\n\n    // Define a &amp;str variable (implicitly typed)\n    let s4: &amp;'static str = \"world\";\n\n    println!(\"s3: {}, s4: {}\", s3, s4);\n}\n</code></pre>"},{"location":"rust-study/04-ownership/2-borrow/#string-slice-techniques","title":"String Slice Techniques","text":"<pre><code>pub fn do_it() {\n    println!(\"\\nIn demo_string_slice_techniques::do_it()\");\n\n    slice_usage();\n    slice_iteration();\n    slice_part_of_string();\n    slice_mutability();\n}\n\nfn slice_usage() {\n\n    // Declare a string slice.\n    let s1 = \"hello\ud83d\ude03\";\n\n    // Note: This examples would also work with String objects.\n    // let s1 = String::from(\"hello\ud83d\ude03\");\n\n    println!(\"\\ns1 ptr: {:p}, len: {}, text: {}\", s1.as_ptr(), s1.len(), s1);\n}\n\nfn slice_iteration() {\n\n    // Declare a string slice.\n    let s2 = \"hello\ud83d\ude03\";\n\n    // Note: This examples would also work with String objects.\n    // let s2 = String::from(\"hello\ud83d\ude03\");\n\n    println!(\"\\nRaw bytes in s2 (in decimal, hex, and octal):\");\n    for b in s2.bytes() {\n        println!(\"  {} {:x} {:o}\", b, b, b);\n    }\n\n    println!(\"Characters in s2:\");\n    for ch in s2.chars() {\n        println!(\"  {}\", ch);\n    }\n}\n\nfn slice_part_of_string() {\n    let message = \"howdy\ud83d\ude0e\";\n\n    // Create slices as a portion of string.\n    let s3 = &amp;message[0..3];\n    let s4 = &amp;message[..3];\n    let s5 = &amp;message[2..5];\n    let s6 = &amp;message[2..];\n\n    println!(\"\\ns3 ptr: {:p}, len: {}, text: {}\", s3.as_ptr(), s3.len(), s3);\n    println!(\"s4 ptr: {:p}, len: {}, text: {}\", s4.as_ptr(), s4.len(), s4);\n    println!(\"s5 ptr: {:p}, len: {}, text: {}\", s5.as_ptr(), s5.len(), s5);\n    println!(\"s6 ptr: {:p}, len: {}, text: {}\", s6.as_ptr(), s6.len(), s6);\n}\n\nfn slice_mutability() {\n    let mut message = String::from(\"croeso\");\n    message.push_str(\" o gymru\");\n\n    if true {\n        let s: &amp;mut str = &amp;mut message[9..];\n        s.make_ascii_uppercase();\n    }\n\n    println!(\"\\nmessage: {}\", message);\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/1-functions/","title":"Naming Conventions","text":"<p>In general, Rust tends to use CamelCase for \"type-level\" constructs (types and traits) and snake_case for \"value-level\" constructs. More precisely:</p> Item Convention Crates snake_case (but prefer single word) Modules snake_case Types CamelCase Traits CamelCase Enum variants CamelCase Functions snake_case Methods snake_case General constructors new or with_more_details Conversion constructors from_some_other_type Local variables snake_case Static variables SCREAMING_SNAKE_CASE Constant variables SCREAMING_SNAKE_CASE Type parameters concise CamelCase, usually single uppercase letter: T Lifetimes short, lowercase: 'a"},{"location":"rust-study/05-structuring-rust-code/1-functions/#passing-parameters-by-value","title":"Passing Parameters by Value","text":"<ul> <li>When passing a copyable value (Copy trait)<ul> <li>Rust bit-copies the value into the parameter</li> <li>The original function retains ownership of the value</li> </ul> </li> <li>When passing a non-copyable value (e.g. String)<ul> <li>Rust moves ownership of the value into the parameter</li> <li>The original function loses ownership of the value!</li> </ul> </li> </ul> <pre><code>pub fn do_it() {\n    println!(\"\\nIn demo_passing_values::do_it()\");\n\n    let n = 42;\n    let s = String::from(\"hello\");\n\n    some_func(n, s);            // Copies n, but moves ownership of s.\n\n    println!(\"n: {}\", n);       // OK. We still own n.\n    // println!(\"s: {}\", s);    // NO! We don't own s.\n}\n\nfn some_func(iparam: i32, sparam: String) {\n    println!(\"In some_func, iparam is {}\", iparam);\n    println!(\"In some_func, sparam is {}\", sparam);\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/1-functions/#module","title":"Module","text":"<p>Define a module using the mod keyword</p> <pre><code>mod foo {\n    pub struct FooError {}\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/1-functions/#functions","title":"Functions","text":""},{"location":"rust-study/05-structuring-rust-code/1-functions/#enum","title":"Enum","text":"<p>Enum is essential in Rust. It is used to define a type by enumerating its possible values.</p>"},{"location":"rust-study/05-structuring-rust-code/1-functions/#defining-and-using-simple-enums","title":"Defining and using simple enums","text":"<ul> <li>Specify the enum type, starting with a capital</li> <li>Specify allowed values (variants), also starting with capitals</li> </ul>"},{"location":"rust-study/05-structuring-rust-code/1-functions/#using-an-enum-type","title":"Using an Enum Type","text":"<ul> <li>Use the enum type, followed by ::, followed by a variant</li> <li>you often use match to test variant values</li> </ul> <pre><code>enum Color {\n    Red,\n    Green,\n    Blue\n}\n\nfn main() {\n    let c: Color = Color::Red;\n\n    match c {\n        Color::Blue =&gt; println!(\"Blue\"),\n        Color::Green =&gt; println!(\"Green\"),\n        Color::Red =&gt; println!(\"Red\"),\n    }\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/1-functions/#avoid-dead-code","title":"Avoid Dead Code","text":"<p>Use some variants but no all. Will get warnings.</p> <ul> <li>To allow dead code, you can use the following attribute:<ul> <li> </li> </ul> </li> </ul>"},{"location":"rust-study/05-structuring-rust-code/1-functions/#allowdead_code","title":"[allow(dead_code)]","text":""},{"location":"rust-study/05-structuring-rust-code/1-functions/#understanding-enum","title":"Understanding Enum","text":"<p>Associate data with variants in enum type</p> <pre><code>enum HouseLocation {\n    Number(i32),\n    Name(String),\n    Unknown\n}\n\nfn main() {\n    let h1 = HouseLocation::Number(32);\n    let h2 = HouseLocation::Name(\"Cartref\");\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/1-functions/#using-the-option-enum","title":"Using the Option enum","text":"<pre><code>enum Option&lt;T&gt; {\n    Some(T),\n    None\n}\n</code></pre> <p>Option is typically used as a function to return type</p> <ul> <li>Indicates the return value might be empty not dealing with null value\\</li> </ul> <pre><code>fn demo_using_option_enum() {\n    println!(\"\\nDemo using the Option&lt;T&gt; enum\");\n\n    let sec: Option&lt;u32&gt;;\n\n    // Uncomment one of the following statements.\n    sec = sec_of_day(23, 59, 59);\n    // sec = sec_of_day(1234, 59, 59);\n\n    match sec {\n        Some(s) =&gt; println!(\"Second of day: {}\", s),\n        None =&gt; println!(\"Second of day: no value available\")\n    }\n\n    // You can use unwrap_or() to extract Some value from an Option, or use a fallback value if None.\n    println!(\"Unwrapped sec: {}\", sec.unwrap_or(0));\n}\n\nfn sec_of_day(h: u32, m: u32, s: u32) -&gt; Option&lt;u32&gt; {\n    return if h &lt;= 23 &amp;&amp; m &lt;= 59 &amp;&amp; s &lt;= 59 {\n        let secs = h * 3600 + m * 60 + s;\n        Option::Some(secs)\n    } else {\n        Option::None\n    };\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/1-functions/#using-the-result-enum","title":"Using the Result enum","text":"<ul> <li>Rust defines a standard enum type name Result:</li> <li>Result represents a value or an error<ul> <li>Might contain a value of some type T</li> <li>Or might contain an error of some type E</li> </ul> </li> <li>This is how Rust indicates errors rather than via exceptions</li> </ul> <pre><code>enum Result&lt;T, E&gt; {\n    OK(T),\n    Err(E)\n}\n</code></pre> <pre><code>fn demo_using_result_enum() {\n    println!(\"\\nDemo using the Result&lt;T, E&gt; enum\");\n\n    let res: Result&lt;i32, std::num::ParseIntError&gt;;\n\n    // Uncomment one of the following statements.\n    res = i32::from_str_radix(\"FF\", 16);\n    // res = i32::from_str_radix(\"wibble\", 16);\n\n    match res {\n        Ok(n) =&gt; println!(\"Parsed str as i32: {}\", n),\n        Err(e) =&gt; println!(\"Error occurred: {}\", e)\n    }\n\n    // You can use unwrap_or() to extract Ok value from a Result, or use a fallback value if Err.\n    let res2 = i32::from_str_radix(\"FF\", 16);\n    println!(\"Unwrapped result: {}\", res2.unwrap_or(-1));\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/1-functions/#passing-reference-parameter","title":"Passing reference parameter","text":"<ul> <li>The called function receives a reference<ul> <li>The called function borrows the value</li> </ul> </li> <li>The calling function retains ownership<ul> <li>The calling function can continue to use the value afterward</li> </ul> </li> <li>To pass a reference parameter into a function<ul> <li>Precede the parameter with &amp;</li> </ul> </li> <li> <p>When a function receives a reference parameter</p> <ul> <li>Use * to de-reference to obtain the underlying value</li> <li>Rust allow a more direct syntax fo invoking methods, no need to de-reference it.</li> </ul> </li> <li> <p>Declare a &amp;str parameter</p> <ul> <li>You can pass in a #String</li> <li>You can pass in a &amp;str. i.e. some_func(\"Jo\"). &amp;String can not receive string literals (\"Jp\")</li> </ul> </li> </ul> <pre><code>pub fn do_it() {\n    println!(\"\\nIn demo_passing_references::do_it()\");\n\n    let n = 42;\n    let s = String::from(\"Ola Nordmann\");\n\n    some_func1(&amp;n, &amp;s);       // Borrows n and s, i.e. passes references.\n    // some_func2(&amp;n, \"Jo\");  // NO! Can't pass &amp;str into &amp;String.\n\n    some_func2(&amp;n, &amp;s);\n    some_func2(&amp;n, \"Siv Nordmann\");\n\n    some_func3(&amp;n, &amp;s);\n    some_func3(&amp;n, \"Per Nordmann\");\n\n    println!(\"n: {}\", n);     // OK. We still own s.\n    println!(\"s: {}\", s);     // OK. We still own n.\n}\n\nfn some_func1(iparam: &amp;i32, sparam: &amp;String) {\n    if *iparam &gt;= 50 {\n        println!(\"{}, {}, PASS \ud83d\ude03\", *iparam, (*sparam).to_uppercase());\n    } else {\n        println!(\"{}, {}, FAIL \ud83d\ude22\", *iparam, (*sparam).to_lowercase());\n    }\n\n    // Note Rust allows you to simplify method calls. Both the following are OK:\n    //   (*sparam).to_uppercase()\n    //   sparam.to_uppercase()\n}\n\nfn some_func2(iparam: &amp;i32, sparam: &amp;str) {\n    if *iparam &gt;= 50 {\n        println!(\"{}, {}, PASS \ud83d\ude03\", *iparam, sparam.to_uppercase());\n    } else {\n        println!(\"{}, {}, FAIL \ud83d\ude22\", *iparam, sparam.to_lowercase());\n    }\n}\n\nfn some_func3(iparam: &amp;i32, sparam: &amp;str) {\n    println!(\"Values {0} and {1}, addresses {0:p} and {1:p}\", iparam, sparam);\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/1-functions/#passing-mutable-reference-parameters","title":"Passing mutable reference parameters","text":"<ul> <li>To pass a mutable reference parameter into a function, precede the parameter with &amp;mut</li> </ul> <pre><code>pub fn do_it() {\n    println!(\"\\nIn demo_returning_mutable_reference::do_it()\");\n\n    let mut s = String::from(\"hello\");\n    let r = some_func(&amp;mut s);    // Receives mutable reference to a String.\n\n    r.push_str(\" and goodbye\");\n    println!(\"r: {}\", r);\n}\n\nfn some_func(s: &amp;mut String) -&gt; &amp;mut String {\n    s.push_str(\" world\");\n    s\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/1-functions/#returning-a-value","title":"Returning a value","text":"<p>syntax: fn some_func(params...) -&gt; some_type {}</p> <pre><code>pub fn do_it() {\n    println!(\"\\nIn demo_returning_value::do_it()\");\n\n    let n = func_returning_copyable_type();         // Receives copy of value.\n    println!(\"n: {}\", n);\n\n    let s = func_returning_non_copyable_type();     // Receives ownership of value.\n    println!(\"s: {}\", s);\n}\n\nfn func_returning_copyable_type() -&gt; i32 {\n    let n = 42;\n    return n;       // Copies value back to caller.\n}\n\nfn func_returning_non_copyable_type() -&gt; String {\n    let s = String::from(\"hello\");\n    return s;       // Moves ownership back to caller.\n}\n\n// This function doesn't compile. \n// It should return a String object.\n// Instead it returns a string literal (i.e. &amp;str).\n// fix it change to String::from(\"PASS\")\n/*\nfn bad_func_returning_string_literal(mark: i32) -&gt; String {\n    return if mark &gt;= 50 {\"PASS\"} else {\"FAIL\"};\n}\n*/\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/1-functions/#return-a-reference","title":"Return a reference","text":""},{"location":"rust-study/05-structuring-rust-code/1-functions/#lifetime-management","title":"Lifetime Management","text":"<p>Lifetime annotations don't change how long references live. They just describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes.</p> <ul> <li>Rust doesn't allow to return a dangling reference<ul> <li>You can't return a reference to a local-based object *</li> </ul> </li> </ul> <pre><code>pub fn do_it() {\n    println!(\"\\nIn demo_returning_reference::do_it()\");\n\n    let s = String::from(\"hello world\");\n\n    let r1 = get_first_word(&amp;s);        // Receives &amp;str (implicit typing).\n    println!(\"r1: {}\", r1);\n\n    let r2: &amp;str = get_first_word(&amp;s);  // Receives &amp;str (explicit typing).\n    println!(\"r2: {}\", r2);\n\n    let message: &amp;str = get_message(99);\n    println!(\"message: {}\", message);\n}\n\nfn get_first_word(s: &amp;str) -&gt; &amp;str {\n    let mut pos = 0;\n    for ch in s.chars() {\n        if ch == ' ' {\n            break;\n        }\n        pos += 1\n    }\n    &amp;s[..pos]\n}\n\nfn get_message(mark: i32) -&gt; &amp;'static str {\n    if mark &gt;= 50 { \"PASS\ud83d\ude03\" } else { \"FAIL\ud83d\ude22\" }\n}\n\n// This won't compile, because it returns a dangling reference.\n/*\nfn bad_func_1() -&gt; &amp;str {\n   let s = String::from(\"hello\");\n   &amp;s                   \n}\n*/\n\n// This won't compile either, because it also returns a dangling reference.\n/*\nfn bad_func_2(s: String) -&gt; &amp;str {\n    let mut pos = 0;\n    for ch in s.chars() {\n        if ch == ' ' {\n            break;\n        } \n        pos += 1\n    }           \n    &amp;s[..pos]\n}\n*/\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/1-functions/#returning-a-mutable-reference","title":"Returning a mutable reference","text":"<pre><code>pub fn do_it() {\n    println!(\"\\nIn demo_returning_mutable_reference::do_it()\");\n\n    let mut s = String::from(\"hello\");\n    let r = some_func(&amp;mut s);    // Receives mutable reference to a String.\n\n    r.push_str(\" and goodbye\");\n    println!(\"r: {}\", r);\n}\n\nfn some_func(s: &amp;mut String) -&gt; &amp;mut String {\n    s.push_str(\" world\");\n    s\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/1-functions/#comments","title":"Comments","text":"<p>All programmers strive to make their code easy to understand, but sometimes extra explanation is warranted. In these cases, programmers leave notes, or comments, in their source code that the compiler will ignore but people reading the source code may find useful.</p> <p>Simple comment:</p> <pre><code>// Hello, world.\n</code></pre> <p>In Rust, comments must start with two slashes and continue until the end of the line. For comments that extend beyond a single line, you\u2019ll need to include // on each line, like this:</p> <pre><code>// So we\u2019re doing something complicated here, long enough that we need\n// multiple lines of comments to do it! Whew! Hopefully, this comment will\n// explain what\u2019s going on.\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/1-functions/#doc-comments","title":"Doc Comments","text":"<p>Doc comments are prefixed by three slashes (///) and indicate documentation that you would like to be included in Rustdoc's output. They support Markdown syntax and are the main way of documenting your public APIs.</p>"},{"location":"rust-study/05-structuring-rust-code/1-functions/#sentence-structure","title":"Sentence structure","text":"<p>All doc comments, including the summary line, should begin with a capital letter and end with a period, question mark, or exclamation point. Prefer full sentences to fragments.</p> <p>The summary line should be written in third-person singular present indicative form. Basically, this means write \" Returns\" instead of \"Return\".</p> <pre><code>/// Sets up a default runtime configuration, given compiler-supplied arguments.\n///\n/// This function will block until the entire pool of M:N schedulers has\n/// exited. This function also requires a local thread to be available.\n///\n/// # Arguments\n///\n/// * `argc` &amp; `argv` - The argument vector. On Unix this information is used\n///                     by `os::args`.\n/// * `main` - The initial procedure to run inside of the M:N scheduling pool.\n///            Once this procedure exits, the scheduling pool will begin to shut\n///            down. The entire pool (and this function) will only return once\n///            all child threads have finished executing.\n///\n/// # Return value\n///\n/// The return value is used as the process return code. 0 on success, 101 on\n/// error.\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/2-nested-functions/","title":"Nested Functions and Closures","text":""},{"location":"rust-study/05-structuring-rust-code/2-nested-functions/#nested-functions","title":"Nested Functions","text":"<ul> <li>You must specify full type info for a nested function, parameter type / return type</li> <li> <p>A nested function cannot access variables in the outer scope - you must pass any variables you need as parameters into   the function</p> </li> <li> <p>Closures overcome these constraints</p> </li> </ul> <pre><code>pub fn do_it() {\n    println!(\"\\nIn demo_nested_functions::do_it()\");\n\n    fn sqr(i: i32) -&gt; i32 {\n        i * i\n    }\n\n    println!(\"Square of 5 is {}\", sqr(5));\n    println!(\"Square of 7 is {}\", sqr(7));\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/2-nested-functions/#closures","title":"Closures","text":"<ul> <li>Closures in Rust are the equivalent of lambdas in other programming languages</li> <li> <p>A closure is similar to a nested function but more flexible in several respects:</p> <ul> <li>a closure can infer parameter/return types</li> <li>a closure can capture external variable</li> </ul> </li> <li> <p>The syntax for defining a closure is similar (but simpler) to defining a nested function:</p> <ul> <li>define parameters inside ||</li> <li>optionally specify parameter/return type</li> <li>define the closure body inside {}</li> </ul> </li> <li> <p>You can assign a closure to a variable</p> <ul> <li>then use the variable as if it were a function name, to invoke the closure</li> </ul> </li> </ul> <pre><code>use chrono::{DateTime, Utc};\nuse std::time::Duration;\nuse std::thread::sleep;\n\npub fn do_it() {\n    println!(\"\\nIn demo_closures::do_it()\");\n\n    closure_no_params();\n    closure_one_param();\n    closure_many_params();\n    closure_multiple_statements();\n}\n\nfn closure_no_params() {\n    let get_timestamp = || -&gt; DateTime&lt;Utc&gt; { Utc::now() };\n    println!(\"Timestamp:   {}\", get_timestamp());//.format(\"%T\"));\n}\n\nfn closure_one_param() {\n    let reciprocal = |n: f64| -&gt; f64 { if n == 0.0 { 0.0 } else { 1.0 / n } };\n    println!(\"Reciprocal:  {}\", reciprocal(5.0));\n}\n\nfn closure_many_params() {\n    let prod = |a: i32, b: i32| -&gt; i32 { a * b };\n    println!(\"Product:     {}\", prod(20, 5));\n}\n\nfn closure_multiple_statements() {\n    let get_timestamp_after_delay = |seconds: u64| -&gt; DateTime&lt;Utc&gt; {\n        sleep(Duration::new(seconds, 0));\n        Utc::now()\n    };\n    println!(\"Timestamp:   {}\", get_timestamp_after_delay(5).format(\"%T\"));\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/2-nested-functions/#using-type-inference-with-closures","title":"Using type inference with closures","text":"<pre><code>use chrono::Utc;\nuse std::time::Duration;\nuse std::thread::sleep;\n\npub fn do_it() {\n    println!(\"\\nIn demo_closures_inferred_types::do_it()\");\n\n    closure_no_params();\n    closure_one_param();\n    closure_many_params();\n    closure_multiple_statements();\n}\n\nfn closure_no_params() {\n    let get_timestamp = || Utc::now();\n    println!(\"Timestamp:   {}\", get_timestamp().format(\"%T\"));\n}\n\nfn closure_one_param() {\n    let reciprocal = |n| if n == 0.0 { 0.0 } else { 1.0 / n };\n\n    // This statement binds the reciprocal() parameter to floating-point.\n    println!(\"Reciprocal:  {}\", reciprocal(5.0));\n\n    // So we can't call reciprocal() with any other type thereafter.\n    // println!(\"Reciprocal:  {}\", reciprocal(5));\n}\n\nfn closure_many_params() {\n    let prod = |a, b| a * b;\n    println!(\"Product:     {}\", prod(20, 5));\n}\n\nfn closure_multiple_statements() {\n    let get_timestamp_after_delay = |seconds| {\n        sleep(Duration::new(seconds, 0));\n        Utc::now()\n    };\n    println!(\"Timestamp:   {}\", get_timestamp_after_delay(5).format(\"%T\"));\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/2-nested-functions/#capturing-variables-by-reference","title":"Capturing variables by reference","text":"<pre><code>pub fn do_it() {\n    println!(\"\\nIn demo_closures_capture_reference::do_it()\");\n\n    capture_immutable_reference();\n    capture_mutable_reference();\n}\n\nfn capture_immutable_reference() {\n    let b1 = String::from(\"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\");\n    let b2 = String::from(\"\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\");\n\n    let display_heading = |s| {\n        println!(\"{}\", b1);\n        println!(\"\u2502 {:&lt;15} \u2502\", s);\n        println!(\"{}\", b2);\n    };\n\n    display_heading(String::from(\"hello\"));\n    display_heading(String::from(\"goodbye!\"));\n\n    println!(\"b1: {}\\nb2: {}\\n\", b1, b2);\n}\n\nfn capture_mutable_reference() {\n    let mut b1 = String::from(\"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\");\n    let mut b2 = String::from(\"\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\");\n\n    let mut display_heading = |s| {\n        b1.push_str(\"\u2705\");\n        b2.push_str(\"\u2705\");\n        println!(\"{}\", b1);\n        println!(\"\u2502 {:&lt;15} \u2502\", s);\n        println!(\"{}\\n\", b2);\n    };\n\n    display_heading(String::from(\"hello\"));\n    display_heading(String::from(\"goodbye!\"));\n\n    println!(\"b1: {}\\nb2: {}\\n\", b1, b2);\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/2-nested-functions/#capturing-variables-by-value","title":"Capturing variables by value","text":"<ul> <li>You can force a closure to capture variables by value, prefix the closure with the move keyword</li> <li>It is useful when you spawn another thread<ul> <li>The thread executes the code in a closure</li> <li>The thread might outlive the outer function</li> <li>So the closure must capture variables by value</li> </ul> </li> </ul> <pre><code>use std::time::Duration;\n\npub fn do_it() {\n    println!(\"\\nIn demo_closures_capture_value::do_it()\");\n\n    capture_value_automatically();\n    capture_value_forcibly();\n\n    // Let's wait a bit before we quit... \n    std::thread::sleep(Duration::new(10, 0))\n}\n\nfn capture_value_automatically() {\n    let message = String::from(\"hello\");\n\n    println!(\"Message initially:  {}\", message);\n\n    // consume_message moves 'message' into closure here.\n    let consume_message = || {\n        println!(\"Message in closure: {}\", message);\n        std::mem::drop(message);\n    };\n\n    // Can't use 'message' here, it's owned by the closure.\n    // println!(\"{}\", message);  // Nope!\n\n    // We can call consume_message() once.\n    consume_message();\n\n    // But we can't call consume_message() again.\n    // consume_message();        // Nope!\n}\n\nfn capture_value_forcibly() {\n    let message = String::from(\"HELLO\");\n\n    println!(\"Start of method...\");\n\n    // We must forcibly move captured values into closure (otherwise it won't compile).\n    std::thread::spawn(move || {\n        println!(\"Message at start of closure: {}\", message);\n        std::thread::sleep(Duration::new(5, 0));\n        println!(\"Message at end of closure:   {}\", message);\n    });\n\n    println!(\"End of method...\");\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/2-nested-functions/#closure-iterator","title":"Closure Iterator","text":"<ul> <li>Rust has a standard type named Iterator<ul> <li>Enables you to iterate over a collection</li> <li>You can perform an operation on each element</li> <li>You specify the operation as a closure</li> </ul> </li> </ul> <pre><code>pub fn do_it() {\n    println!(\"\\nIn demo_closures_iteration::do_it()\");\n\n    demo_simple_iteration();\n    demo_unused_closure_variable();\n    demo_filtering_maping();\n    demo_collecting_result();\n}\n\nfn demo_simple_iteration() {\n    let v = vec![\"donald\", \"huey\", \"louie\", \"dewey\"];\n\n    println!(\"All ducks:\");\n    v.iter()\n        .for_each(|e| println!(\"   {}\", e));\n}\n\nfn demo_unused_closure_variable() {\n    let v = vec![\"donald\", \"huey\", \"louie\", \"dewey\"];\n\n    println!(\"Redacted ducks:\");\n    v.iter()\n        .for_each(|_| println!(\"   xxx\"));\n}\n\nfn demo_filtering_maping() {\n    let v = vec![\"donald\", \"huey\", \"louie\", \"dewey\"];\n\n    println!(\"Uppercase 'd' ducks:\");\n    v.iter()\n        .filter(|e| e.starts_with('d'))\n        .map(|e| e.to_uppercase())\n        .for_each(|e| println!(\"   {}\", e));\n}\n\nfn demo_collecting_result() {\n    let v = vec![\"donald\", \"huey\", \"louie\", \"dewey\"];\n\n    let upper_y_ducks =\n        v.iter()\n            .filter(|e| e.ends_with('y'))\n            .map(|e| e.to_uppercase())\n            .collect::&lt;Vec&lt;String&gt;&gt;();\n\n    println!(\"There are {} ducks ending with 'y':\", upper_y_ducks.len());\n    upper_y_ducks.iter()\n        .for_each(|e| println!(\"   {}\", e));\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/3-defining-and-instantiating-structs/","title":"Defining and Instantiating Structs","text":""},{"location":"rust-study/05-structuring-rust-code/3-defining-and-instantiating-structs/#defining-struct","title":"Defining struct","text":"<ul> <li>Use the struct keyword</li> <li>Give the struct name, starting with a capital</li> <li>Define field names and types</li> </ul> <pre><code>struct User {\n    username: String,\n    email: String,\n    sign_in_count: u64,\n    active: bool,\n}\n</code></pre> <p>Instantiating struct</p> <pre><code>struct User {\n    username: String,\n    email: String,\n    sign_in_count: u64,\n    active: bool,\n}\n\nfn main() {\n    let user1 = User {\n        email: String::from(\"someone@examples.com\"),\n        username: String::from(\"someusername123\"),\n        active: true,\n        sign_in_count: 1,\n    };\n}\n</code></pre> <p>To get a specific value from a struct, we can use dot notation. If we wanted just this user\u2019s email address, we can use user1.email wherever we want to use this value. If the instance is mutable, we can change a value by using the dot notation and assigning into a particular field. Listing 5-3 shows how to change the value in the email field of a mutable User instance:</p> <pre><code>struct User {\n    username: String,\n    email: String,\n    sign_in_count: u64,\n    active: bool,\n}\n\nfn main() {\n    let mut user1 = User {\n        email: String::from(\"someone@examples.com\"),\n        username: String::from(\"someusername123\"),\n        active: true,\n        sign_in_count: 1,\n    };\n    user1.email = String::from(\"anotheremail@examples.com\");\n    z\n}\n</code></pre> <p>build_user function that returns a User instance with the given email and username. The active field gets the value of true, and the sign_in_count gets a value of 1.</p> <pre><code>struct User {\n    username: String,\n    email: String,\n    sign_in_count: u64,\n    active: bool,\n}\n\nfn build_user(email: String, username: String) -&gt; User {\n    User {\n        email: email,\n        username: username,\n        active: true,\n        sign_in_count: 1,\n    }\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/3-defining-and-instantiating-structs/#passing-struct-parameters-by-value","title":"Passing struct parameters by value","text":"<p>It depends on struct implementing Copy trait or not</p> <ul> <li>if implementing Copy trait<ul> <li>a bitwise copy of the struct is passed to the called function</li> <li>The caller retains ownership and can use the struct afterwards</li> </ul> </li> <li>if not implementing Copy trait<ul> <li>Ownership of the struct is moved to the called function</li> <li>The caller loses ownership and can't use the struct afterwards</li> </ul> </li> </ul> <pre><code>use crate::my_types::Employee;\n\npub fn do_it() {\n    println!(\"\\nIn demo_struct_pass_value::do_it()\");\n\n    let e1 = Employee {\n        name: String::from(\"John\"),\n        salary: 1000,\n        fulltime: false,\n    };\n\n    // Pass struct by value (and move ownership into the function).\n    consume_employee(e1);\n\n    // Can't use e1 now...\n    // println!(\"{}\", e1.name);\n}\n\nfn consume_employee(e: Employee) {\n    println!(\n        \"{} earns {}, fulltime status: {}\",\n        e.name, e.salary, e.fulltime\n    );\n} // Employee object dropped here.\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/3-defining-and-instantiating-structs/#passing-struct-parameters-as-by-reference","title":"Passing struct parameters as by reference","text":"<pre><code>use crate::mytypes::Employee;\n\npub fn do_it() {\n    println!(\"\\nIn demo_struct_pass_reference::do_it()\");\n\n    let mut e1 = Employee {\n        name: String::from(\"Jane\"),\n        salary: 1000,\n        fulltime: true,\n    };\n\n    // Pass struct by reference.\n    print_employee(&amp;e1);\n\n    // Pass struct by mutable reference.\n    reward_employee(&amp;mut e1);\n    print_employee(&amp;e1);\n}\n\nfn print_employee(e: &amp;Employee) {\n    println!(\n        \"Using explicit dereferencing: {} earns {}, fulltime status: {}\",\n        (*e).name,\n        (*e).salary,\n        (*e).fulltime\n    );\n    println!(\n        \"Using implicit dereferencing: {} earns {}, fulltime status: {}\",\n        e.name, e.salary, e.fulltime\n    );\n}\n\nfn reward_employee(e: &amp;mut Employee) {\n    // Using explicit dereferencing.\n    (*e).salary += 500;\n\n    // Using implicit dereferencing.\n    e.salary += 250;\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/3-defining-and-instantiating-structs/#return-struct-as-value","title":"Return struct as value","text":"<pre><code>use crate::mytypes::Employee;\n\npub fn do_it() {\n    println!(\"\\nIn demo_struct_return_value::do_it()\");\n\n    let e1 = build_employee(String::from(\"Jane\"), 1000, true);\n    print_employee(&amp;e1);\n\n    let mut e2 = build_employee_v2(String::from(\"John\"), 1000, false);\n    e2.salary += 750;\n    print_employee(&amp;e2);\n}\n\nfn build_employee(name: String, salary: u64, fulltime: bool) -&gt; Employee {\n    Employee {\n        name: name,\n        salary: salary,\n        fulltime: fulltime,\n    }\n}\n\nfn build_employee_v2(name: String, salary: u64, fulltime: bool) -&gt; Employee {\n    Employee {\n        name,\n        salary,\n        fulltime,\n    }\n}\n\nfn print_employee(emp: &amp;Employee) {\n    println!(\n        \"{} earns {}, fulltime status: {}\",\n        emp.name, emp.salary, emp.fulltime\n    );\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/3-defining-and-instantiating-structs/#return-struct-as-reference","title":"Return struct as reference","text":"<ul> <li>&lt;'a&gt; is a lifetime annotation, letter a can be anything name, like b, c or z.</li> <li>We apply 'a to each reference param to indicate that they have the same lifetime.</li> </ul> <pre><code>use crate::mytypes::Employee;\n\npub fn do_it() {\n    println!(\"\\nIn demo_struct_return_reference::do_it()\");\n\n    let mut e1 = build_employee(String::from(\"Jane\"), 1001, true);\n    let mut e2 = build_employee(String::from(\"John\"), 1000, false);\n\n    let ri = choose_employee(&amp;e1, &amp;e2);\n    print_employee(ri);\n\n    let rm = choose_mut_employee(&amp;mut e1, &amp;mut e2);\n    rm.salary *= 2;\n    print_employee(rm);\n}\n\nfn build_employee(name: String, salary: u64, fulltime: bool) -&gt; Employee {\n    Employee {\n        name,\n        salary,\n        fulltime,\n    }\n}\n\nfn choose_employee&lt;'a&gt;(e1: &amp;'a Employee, e2: &amp;'a Employee) -&gt; &amp;'a Employee {\n    if e1.salary &gt; e2.salary {\n        e1\n    } else {\n        e2\n    }\n}\n\nfn choose_mut_employee&lt;'a&gt;(e1: &amp;'a mut Employee, e2: &amp;'a mut Employee) -&gt; &amp;'a mut Employee {\n    if e1.salary &gt; e2.salary {\n        e1\n    } else {\n        e2\n    }\n}\n\nfn print_employee(e: &amp;Employee) {\n    println!(\n        \"{} earns {}, fulltime status: {}\",\n        e.name, e.salary, e.fulltime\n    );\n} \n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/4-struct-impl/","title":"Implementing Functionality in a Struct","text":""},{"location":"rust-study/05-structuring-rust-code/4-struct-impl/#defining-functionality-for-a-struct","title":"Defining Functionality for a Struct","text":"<ul> <li>Define a function inside the impl block</li> <li>The first parameter must be name self, must be a reference to borrow the instance</li> <li>fn function_name(self: &amp;Self) {}</li> <li>shorthand syntax fn function_name(&amp;self) {}, most developers use this because of legible</li> </ul> <pre><code>struct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Point {\n    fn print_v1(&amp;self) {\n        println!(\"In print_v1(), point is [{},{}]\", self.x, self.y);\n    }\n\n    // Alternatively, you can explicitly specify the type of self.\n    fn print_v2(self: &amp;Point) {\n        println!(\"In print_v2(), point is [{},{}]\", self.x, self.y);\n    }\n\n    // Alternatively, you can use Self as an alias for the type of self.\n    fn print_v3(self: &amp;Self) {\n        println!(\"In print_v3(), point is [{},{}]\", self.x, self.y);\n    }\n\n    fn to_string(&amp;self) -&gt; String {\n        format!(\"[{},{}]\", self.x, self.y)\n    }\n}\n\npub fn do_it() {\n    println!(\"\\nIn demo_simple_impl::do_it()\");\n\n    let p1 = Point { x: 10, y: 20 };\n\n    p1.print_v1();\n    p1.print_v2();\n    p1.print_v3();\n\n    println!(\"{}\", p1.to_string());\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/4-struct-impl/#implementing-mutable-reference","title":"Implementing mutable reference","text":"<p>If you want to allow a method to modify an instance</p> <ul> <li>define self as a mutable reference</li> <li>fn reset(self: &amp;mut struct_name){}</li> <li>or fn reset(self: &amp;mut Self){}</li> <li>or fn reset(&amp;mut self){}, shorthand preferable.</li> </ul> <pre><code>#![allow(dead_code)]\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Point {\n    fn print(&amp;self) {\n        println!(\"In print(), Point is [{},{}]\", self.x, self.y);\n    }\n\n    fn to_string(&amp;self) -&gt; String {\n        format!(\"[{},{}]\", self.x, self.y)\n    }\n\n    fn reset_v1(&amp;mut self) {\n        self.x = 0;\n        self.y = 0;\n    }\n\n    // Alternatively, you can explicitly specify the type of self.\n    fn reset_v2(self: &amp;mut Point) {\n        self.x = 0;\n        self.y = 0;\n    }\n\n    // Alternatively, you can use Self as an alias for the type of self.\n    fn reset_v3(self: &amp;mut Self) {\n        self.x = 0;\n        self.y = 0;\n    }\n\n    fn move_by(&amp;mut self, dx: i32, dy: i32) {\n        self.x += dx;\n        self.y += dy;\n    }\n}\n\npub fn do_it() {\n    println!(\"\\nIn demo_mutable_impl::do_it()\");\n\n    let mut p1 = Point { x: 10, y: 20 };\n\n    p1.move_by(100, 200);\n    println!(\"{}\", p1.to_string());\n\n    p1.reset_v1();\n    p1.reset_v2();\n    p1.reset_v3();\n    println!(\"{}\", p1.to_string());\n}\n</code></pre>"},{"location":"rust-study/05-structuring-rust-code/4-struct-impl/#organizing-code-into-modules","title":"Organizing code into modules","text":""},{"location":"rust-study/05-structuring-rust-code/4-struct-impl/#defining-associated-functions","title":"Defining associated functions","text":""},{"location":"rust-study/05-structuring-rust-code/4-struct-impl/#defining-associated-data","title":"Defining associated data","text":""},{"location":"rust-study/06-enum-and-pattern-matching/1-enum/","title":"Defining an Enum","text":"<p>We can express this concept in code by defining an IpAddrKind enumeration and listing the possible kinds an IP address can be, V4 and V6. These are known as the variants of the enum:</p> <pre><code>enum IpAddrKind {\n    V4,\n    V6,\n}\n</code></pre> <pre><code>use std::net::IpAddr;\n\nenum IpAddr {\n    V4(String),\n    V6(String),\n}\n\nlet home = IpAddr::V4(String::from(\"127.0.0.1\"));\nlet loopback = IpAddr::V6(String::from(\"::1\"));\n</code></pre> <pre><code>enum IpAddr {\n    V4(u8, u8, u8, u8),\n    V6(String),\n}\n\nlet home = IpAddr::V4(127, 0, 0, 1);\nlet loopback = IpAddr::V6(String::from(\"::1\"));\n</code></pre> <pre><code>enum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n</code></pre>"},{"location":"rust-study/06-enum-and-pattern-matching/1-enum/#the-match-control-flow-operator","title":"The match Control Flow Operator","text":"<pre><code>enum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -&gt; u32 {\n    match coin {\n        Coin::Penny =&gt; 1,\n        Coin::Nickel =&gt; 5,\n        Coin::Dime =&gt; 10,\n        Coin::Quarter =&gt; 25,\n    }\n}\n</code></pre>"},{"location":"rust-study/06-enum-and-pattern-matching/1-enum/#matching-with-option","title":"Matching with Option <pre><code>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {\n    match x {\n        None =&gt; None,\n        Some(i) =&gt; Some(i + 1),\n    }\n}\n\nlet five = Some(5);\nlet six = plus_one(five);\nlet none = plus_one(None);\n</code></pre>","text":""},{"location":"rust-study/06-enum-and-pattern-matching/1-enum/#the-_-placeholder","title":"The _ Placeholder <p>Rust also has a pattern we can use in situations when we don\u2019t want to list all possible values. For example, a u8 can have valid values of 0 through 255. If we only care about the values 1, 3, 5, and 7, we don\u2019t want to have to list out 0, 2, 4, 6, 8, 9 all the way up to 255. Fortunately, we don\u2019t have to: we can use the special pattern _ instead:</p> <pre><code>let some_u8_value = 0u8;\nmatch some_u8_value {\n    1 =&gt; println!(\"one\"),\n    3 =&gt; println!(\"three\"),\n    5 =&gt; println!(\"five\"),\n    7 =&gt; println!(\"seven\"),\n    _ =&gt; (),\n}\n</code></pre>","text":""},{"location":"rust-study/06-enum-and-pattern-matching/1-enum/#concise-control-flow-with-if-let","title":"Concise Control Flow with if let <p>The if let syntax lets you combine if and let into a less verbose way to handle values that match one pattern and ignore the rest. Consider the program in Listing 6-6 that matches on an Option value but only wants to execute code if the value is three: <pre><code>let some_u8_value = Some(0u8);\nmatch some_u8_value {\n    Some(3) =&gt; println!(\"three\"),\n    _ =&gt; (),\n}\n</code></pre> <p>We want to do something with the Some(3) match but do nothing with any other Some value or the None value. To satisfy the match expression, we have to add _ =&gt; () after processing just one variant, which is a lot of boilerplate code to add. <p>Instead, we could write this in a shorter way using if let. The following code behaves the same as the match in Listing 6-6:</p> <pre><code>let some_u8_value = Some(0u8);\nif let Some(3) = some_u8_value {\n    println!(\"three\");\n}\n</code></pre>","text":""},{"location":"rust-study/06-enum-and-pattern-matching/2-channel/","title":"Channel","text":"<p>Creating a channel in Go requires the use of the built-in function make.</p> <pre><code>// Unbuffered channel of integers.\nunbuffered := make(chan int)\n\n// Buffered channel of strings.\nbuffered := make(chan string, 10)\n</code></pre>"},{"location":"rust-study/06-enum-and-pattern-matching/2-channel/#unbuffered-channels","title":"Unbuffered Channels","text":"<p>An unbuffered channel is a channel with no capacity to hold any value before it\u2019s received. These types of channels require both a sending and receiving goroutine to be ready at the same instant before any send or receive operation can complete. If the two goroutines aren\u2019t ready at the same instant, the channel makes the goroutine that performs its respective send or receive operation first wait. Synchronization is inherent in the interaction between the send and receive on the channel. One can\u2019t happen without the other.</p>"},{"location":"rust-study/06-enum-and-pattern-matching/2-channel/#buffered-channels","title":"Buffered Channels","text":"<p>A buffered channel is a channel with capacity to hold one or more values before they\u2019re received. These types of channels don\u2019t force goroutines to be ready at the same instant to perform sends and receives. There are also different conditions for when a send or receive does block. A receive will block only if there\u2019s no value in the channel to receive. A send will block only if there\u2019s no available buffer to place the value being sent. This leads to the one big difference between unbuffered and buffered channels: An unbuffered channel provides a guarantee that an exchange between two goroutines is performed at the instant the send and receive take place. A buffered channel has no such guarantee.</p>"},{"location":"rust-study/06-enum-and-pattern-matching/2-channel/#summary","title":"Summary","text":"<ul> <li>Concurrency is the independent execution of goroutines.</li> <li>Functions are created as goroutines with the keyword go.</li> <li>Goroutines are executed within the scope of a logical processor that owns a single operating system thread and run   queue.</li> <li>A race condition is when two or more goroutines attempt to access the same resource.</li> <li>Atomic functions and mutexes provide a way to protect against race conditions.</li> <li>Channels provide an intrinsic way to safely share data between two goroutines.</li> <li>Unbuffered channels provide a guarantee between an exchange of data. Buffered channels do not.</li> </ul>"},{"location":"rust-study/07-modules/1-mod/","title":"Using Modules to Reuse and Organize Code","text":"<p>As your code grows, you\u2019ll eventually move functionality into other functions for reuse and better organization. By splitting your code into smaller chunks, each chunk is easier to understand on its own. But what happens if you have too many functions? Rust has a module system that enables the reuse of code in an organized fashion.</p> <p>In the same way that you extract lines of code into a function, you can extract functions (and other code, like structs and enums) into different modules. A module is a namespace that contains definitions of functions or types, and you can choose whether those definitions are visible outside their module (public) or not (private). Here\u2019s an overview of how modules work:</p> <ul> <li>The mod keyword declares a new module. Code within the module appears either immediately following this declaration   within curly brackets or in another file.</li> <li>By default, functions, types, constants, and modules are private. The pub keyword makes an item public and therefore   visible outside its namespace.</li> <li>The use keyword brings modules, or the definitions inside modules, into scope, so it\u2019s easier to refer to them.</li> </ul>"},{"location":"rust-study/07-modules/1-mod/#modules","title":"Modules","text":"<ul> <li>Subdivide code to group related items</li> <li>Provide isolate namespaces to control scope and privacy</li> <li>Can contain Functions, Macros, Types, Traits, impl blocks and even modules</li> </ul>"},{"location":"rust-study/07-modules/1-mod/#paths","title":"Paths","text":"<ul> <li>Reference items within the module system</li> <li>Can be relative or absolute</li> </ul>"},{"location":"rust-study/07-modules/1-mod/#crates","title":"Crates","text":"<ul> <li>Types of crates<ul> <li>Binary crate</li> <li>Library crate</li> </ul> </li> </ul>"},{"location":"rust-study/07-modules/1-mod/#packages","title":"Packages","text":"<ul> <li>Used to build, test, and share crates with Cargo</li> <li>Contains one or more target crates<ul> <li>Up to one library crate</li> <li>Zero to many binary crates</li> </ul> </li> </ul>"},{"location":"rust-study/07-modules/1-mod/#package-and-crate","title":"Package and Crate","text":""},{"location":"rust-study/07-modules/2-mod-and-filesystem/","title":"mod and the Filesystem","text":"<pre><code>cargo new --lib communicator\ncd communicator\n</code></pre> <p>library crate communicator</p> <pre><code>communicator\n|- Cargo.toml\n|- src\n  |- lib.rs\n</code></pre> <p>cargo new --bin hello-rust binary crate hello-rust</p> <pre><code>hello-rust\n|- Cargo.toml\n|- src\n  |- main.rs\n</code></pre> <p>cargo new communicator - creates a crate called communicator.</p> <ul> <li>repo could contain 1 or more crates</li> <li>crate contains 1 or more modules</li> <li>module could contain modules, functions, enums and structs</li> </ul> <p>Filename: src/lib.rs</p> <pre><code>mod network {\n    fn connect() {\n    }\n}\n\nmod client {\n    fn connect() {\n    }\n    mod server {\n        fn connect() {\n        }\n    }\n}\n</code></pre> <pre><code>communicator\n\u251c\u2500\u2500 client\n\u2514\u2500\u2500 network\n    \u2514\u2500\u2500 server\n</code></pre> <p>If these modules had many functions, and those functions were becoming lengthy, it would be difficult to scroll through this file to find the code we wanted to work with. Because the functions are nested inside one or more mod blocks, the lines of code inside the functions will start getting lengthy as well. These would be good reasons to separate the client, network, and server modules from src/lib.rs and place them into their own files.</p> <pre><code>mod client;\n\nmod network {\n    fn connect() {\n    }\n\n    mod server {\n        fn connect() {\n        }\n    }\n}\n</code></pre> <p>src/client.rs</p> <pre><code>fn connect()  {\n}\n</code></pre> <p>src/lib.rs</p> <pre><code>mod client;\nmod network;\n</code></pre> <p>src/network.rs</p> <pre><code>fn connect() {\n}\n\nmod server {\n    fn connect() {\n    }\n}\n</code></pre> <p>Instead of continuing to follow the same file naming pattern we used previously, we can do what the note suggests:</p> <ol> <li>Make a new directory named network, the parent module\u2019s name.</li> <li>Move the src/network.rs file into the new network directory, and rename it to src/network/mod.rs.</li> <li>Move the submodule file src/server.rs into the network directory.</li> </ol> <p>Here are commands to carry out these steps:</p> <pre><code>$ mkdir src/network\n$ mv src/network.rs src/network/mod.rs\n$ mv src/server.rs src/network\n</code></pre> <p>The corresponding file layout now looks like this:</p> <pre><code>\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 client.rs\n\u2502   \u251c\u2500\u2500 lib.rs\n\u2502   \u2514\u2500\u2500 network\n\u2502       \u251c\u2500\u2500 mod.rs\n\u2502       \u2514\u2500\u2500 server.rs\n</code></pre>"},{"location":"rust-study/07-modules/2-mod-and-filesystem/#rules-of-module-filesystems","title":"Rules of Module Filesystems","text":"<p>Let\u2019s summarize the rules of modules with regard to files:</p> <ul> <li>If a module named foo has no submodules, you should put the declarations for foo in a file named foo.rs.</li> <li>If a module named foo does have submodules, you should put the declarations for foo in a file named foo/mod.rs.</li> </ul>"},{"location":"rust-study/07-modules/3-test-functions/","title":"Rust Test Functions","text":""},{"location":"rust-study/07-modules/3-test-functions/#assert-macro","title":"assert! Macro","text":"<ul> <li>Evaluates a single Boolean argument</li> <li>if true, do nothing</li> <li>if false, call the panic! macro</li> </ul>"},{"location":"rust-study/08-common-collections/01-collections/","title":"Collections","text":"<ul> <li>Collections are data structures that can hold multiple values.</li> <li>Rust standard library provides a number of useful collection types.</li> <li>The most common collections are:<ul> <li>Sequences: Vec, VecDeque, LinkedList</li> <li>Vec: A growable array</li> <li>VecDeque: A double-ended queue</li> <li>LinkedList: A doubly-linked list (rarely used)</li> <li>Maps: HashMap, BTreeMap</li> <li>HashMap: A collection of key-value pairs</li> <li>BTreeMap: A collection of key-value pairs sorted by key and use for search</li> <li>Sets: HashSet, BTreeSet</li> <li>HashSet: A collection of unique values</li> <li>BTreeSet: A collection of unique values sorted by key - optimized for search</li> <li>Misc.: BinaryHeap</li> <li>BinaryHeap: A priority queue - is very niche and not used often</li> </ul> </li> </ul>"},{"location":"rust-study/08-common-collections/01-collections/#most-useful-collections","title":"Most Useful Collections","text":"<ul> <li>Vec: A growable array</li> <li>HashMap: A collection of key-value pairs</li> <li>Strings: A growable UTF-8 encoded text</li> </ul> <pre><code>fn main() {\n    // Simple vectors/strings\n    let mut my_vec = vec![1, 2, 3, 4, 5];\n    // adding a value to the vector\n    my_vec.push(6);\n\n    // initializing a String - high-level wrapper around Vec&lt;byte&gt;\n    let message = String::from(\"Hello, World!\");\n\n    // initializing a HashMap\n    let mut coffee_ratings = HashMap::new();\n    coffee_ratings.insert(\"Latte\", 10);\n\n    for (name, rating) in &amp;coffee_ratings {\n        println!(\"{}: {}\", name, rating);\n    };\n}\n</code></pre>"},{"location":"rust-study/08-common-collections/01-collections/#primitive-types","title":"Primitive Types","text":"<p>Array is fixed-size and cannot grow or shrink. Tuple a fixed number of elements, sequence of elements, and these elements can have different types. Slices are references to a contiguous sequence of elements in a collection.</p> <pre><code>fn main() {\n    // Array\n    let my_array: [u8; 5] = [1, 2, 3, 4, 5];\n\n    // Tuple\n    let my_tuple = (1, \"hello\", 4.5, true);\n\n    // Slices\n    let my_slice = &amp;my_array[1..3];\n}\n</code></pre>"},{"location":"rust-study/09-error-handling/1-option-and-result/","title":"1 option and result","text":"<pre><code>    # Error Handling\n</code></pre>"},{"location":"rust-study/09-error-handling/1-option-and-result/#resources","title":"Resources","text":"<p>Some links to help you understand error handling in Rust.</p> Topic Link Deep Dive https://www.lpalmieri.com/posts/error-handling-rust/ Error Handle Patterns https://www.youtube.com/watch?v=f82wn-1DPas Get Rusty - Error Handler https://www.youtube.com/watch?v=wM6o70NAWUI&amp;t=549s"},{"location":"rust-study/09-error-handling/1-option-and-result/#error-handle-patterns","title":"Error Handle Patterns","text":""},{"location":"rust-study/09-error-handling/1-option-and-result/#option","title":"Option","text":"<p>Type Option represents an optional value: every Option is either Some and contains a value, or None, and does not. Option types are very common in Rust code, as they have a number of uses:</p> <pre><code>pub enum Option&lt;T&gt; {\n    None,\n    Some(T)\n}\n</code></pre>"},{"location":"rust-study/09-error-handling/1-option-and-result/#result","title":"Result","text":"<p>Result is a type that represents either success (Ok) or failure (Err). It is often used to return errors to the caller.</p> <pre><code>pub enum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n</code></pre> <ol> <li>a function that takes a vector of strings</li> <li>parse each string into a integer</li> <li>computes the sum of all those integers</li> <li>converts the result into a string</li> <li>returns the string to the caller</li> </ol> <pre><code>fn sum_of_strings(strs: Vec&lt;&amp;str&gt;) -&gt; String {\n    let mut sum = 0;\n    for s in strs {\n        sum += to_int(&amp;s);\n    }\n\n    sum.to_string()\n}\n\nfn to_int(s: &amp;str) -&gt; i32 {\n    s.parse::&lt;i32&gt;().unwrap()\n}\n\nfn main() {\n    let strs = vec![\"1\", \"2\", \"3\"];\n    let sum = sum_of_strings(strs);\n    println!(\"sum: {:?}\", sum);\n}\n</code></pre> <ul> <li>Should not use unwrap in production code. It will panic (end the function prematurely) if the string is not a valid   integer. Using unwrap is meant to defer error handling to the caller.</li> <li>Use expect to provide a more informative error message. However, it still panics if the string is not a valid integer.</li> </ul> <pre><code>fn to_int(s: &amp;str) -&gt; i32 {\n    s.parse::&lt;i32&gt;().expect(\"Failed to parse string to integer\")\n}\n</code></pre> <ul> <li>use unwrap_or to provide a default value if the string is not a valid integer.</li> </ul> <pre><code>fn to_int(s: &amp;str) -&gt; i32 {\n    s.parse::&lt;i32&gt;().unwrap_or(0)\n}\n</code></pre> <ul> <li>use Option to handle the error. It returns None if the string is not a valid integer.</li> </ul> <pre><code>fn to_int(s: &amp;str) -&gt; Option&lt;i32&gt; {\n    s.parse().ok()\n}\n\nfn sum_of_strings(strs: Vec&lt;&amp;str&gt;) -&gt; String {\n    let mut sum = 0;\n    for s in strs {\n        sum += match to_int(&amp;s) {\n            Some(i) =&gt; i,\n            None =&gt; 0,\n        };\n    }\n\n    sum.to_string()\n}\n</code></pre> <pre><code>fn sum_of_strings(strs: Vec&lt;&amp;str&gt;) -&gt; String {\n    let mut sum = 0;\n    for s in strs {\n        if let Some(val) = to_int(&amp;s) {\n            sum += val;\n        };\n    }\n\n    sum.to_string()\n}\n</code></pre> <ul> <li>use question mark operator to propagate the error to the caller.</li> </ul> <pre><code>fn sum_of_strings(strs: Vec&lt;&amp;str&gt;) -&gt; Option&lt;String&gt; {\n    let mut sum = 0;\n    for s in strs {\n        let val =  to_int(&amp;s)?;\n        sum += val;\n    }\n\n    Ok(sum.to_string())\n}\n</code></pre> <ul> <li>use Result to handle the error. It returns an error if the string is not a valid integer.</li> </ul> <pre><code>#[derive(Debug)]\nstruct SummationError;\nfn sum_of_strings(strs: Vec&lt;&amp;str&gt;) -&gt; Result&lt;String, SummationError&gt; {\n    let mut sum = 0;\n    for s in strs {\n        let val =  to_int(&amp;s).ok_or(SummationError)?;\n        sum += val;\n    }\n\n    Ok(sum.to_string())\n}\n</code></pre>"},{"location":"rust-study/09-error-handling/1-option-and-result/#summary","title":"Summary","text":"<ul> <li>unwrap - extracts a value from a container or panics if the value is None or Err.</li> <li>ok - converts a Result to an Option.</li> <li>map - transforms the value inside a container. but with a different type.</li> <li>? - propagates the error to the caller.</li> </ul>"},{"location":"rust-study/09-error-handling/2-rust-error/","title":"Rust - Error Handling","text":"<p>Rust has a robust error handling system built into the language. Rust uses the <code>Result</code> enum to handle errors. The <code>Result</code> enum has two variants: <code>Ok</code> and <code>Err</code>. The <code>Ok</code> variant is used to return a value when the operation is successful, and the <code>Err</code> variant is used to return an error when the operation fails.</p>"},{"location":"rust-study/09-error-handling/2-rust-error/#panic-unrecoverable-errors","title":"Panic (Unrecoverable Errors)","text":"<p>Panic is a mechanism used to handle unrecoverable errors. When a panic occurs, the program will print an error message and exit. Panics are used to handle errors that are not recoverable, such as out-of-bounds array access or division by zero.</p> <pre><code>fn main() {\n    panic!(\"This is a panic!\");\n}\n</code></pre>"},{"location":"rust-study/09-error-handling/2-rust-error/#recoverable-errors","title":"Recoverable Errors","text":"<p>Recoverable errors are errors that can be handled by the program. Rust uses the <code>Result</code> enum to handle recoverable errors. The <code>Result</code> enum has two variants: <code>Ok</code> and <code>Err</code>. The <code>Ok</code> variant is used to return a value when the operation is successful, and the <code>Err</code> variant is used to return an error when the operation fails.</p> <pre><code>fn main() {\n    let result: Result&lt;i32, String&gt; = Ok(42);\n    match result {\n        Ok(value) =&gt; println!(\"Result: {}\", value),\n        Err(error) =&gt; println!(\"Error: {}\", error),\n    }\n}\n</code></pre>"},{"location":"rust-study/10-generic-type-traits-lifetimes/Injection/","title":"Injection","text":"<p>are forced to appear all over the code). Instead, put it on the functions or impls which require that trait.</p> <pre><code>pub struct Bar&lt;'a, T&gt; { // Note: No mention of SomeTrait here\n    abc: &amp;'a str,\n    def: T,\n}\n\nimpl&lt;'a, T&gt; Bar&lt;'a&gt; \n    where T: SomeTrait   // &lt;-- this is where we do it\n    {\n    pub fn some_function(&amp;self)  {\n    self.def.foo();\n    }\n}\n</code></pre> <p>There are only three instances where you are required to put a bound in the struct itself:</p> <p>when the object has a field of an associated type (see std::borrow::Cow 6 which has a ToOwned bound because it actually may contain the associated type :: Owned) (similarly Peekable 2 holds a ::Item) when that trait is used in the destructor (examples are rare; I could only find one 1 in the standard library; that type needs Ord because its drop impl calls a method that requires Ord) when you carry another struct that has a bound. (see? It's infectous!)"},{"location":"rust-study/10-generic-type-traits-lifetimes/Injection/#rust-dependency-injection-implementation-of-trait-into-another-object","title":"Rust Dependency Injection implementation of trait into another object","text":"<pre><code>pub trait Downloader {\n    fn run(&amp;self);\n}\n\npub struct DownloaderFoo;\nimpl Downloader for DownloaderFoo {\n    fn run(&amp;self)  {\n        println!(\"DownloaderFoo::run\");\n    }\n}\n\npub struct DownloaderBar;\nimpl Downloader for DownloaderBar {\n    fn run(&amp;self)  {\n        println!(\"DownloaderBar::run\");\n    }\n}\n\npub struct Installer {\n    downloader: Box&lt;dyn Downloader&gt;,\n}\n\nimpl Installer {\n    pub fn run(&amp;self) {\n        self.downloader.run();\n        println!(\"Installer::run\");\n    }\n}\n\nfn main() {\n    Installer{downloader: Box::new(DownloaderFoo{})}.run();\n    Installer{downloader: Box::new(DownloaderBar{})}.run();\n}\n</code></pre>"},{"location":"rust-study/10-generic-type-traits-lifetimes/generics/","title":"Generics","text":"<ul> <li>Generics are a way to define a type or function without specifying the exact type it will work with.</li> <li>Reusable code can be written with generics.</li> <li>Reduces code duplication.</li> </ul>"},{"location":"rust-study/10-generic-type-traits-lifetimes/generics/#defining-a-generic-function","title":"Defining a Generic Function","text":"<pre><code>fn print_type&lt;T&gt;(value: T) {\n    println!(\"{}\", std::any::type_name::&lt;T&gt;());\n}\n</code></pre>"},{"location":"rust-study/10-generic-type-traits-lifetimes/generics/#defining-a-generic-struct","title":"Defining a Generic Struct","text":"<pre><code>struct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n</code></pre>"},{"location":"rust-study/10-generic-type-traits-lifetimes/generics/#implementing-a-generic-method","title":"Implementing a Generic Method","text":"<pre><code>impl&lt;T&gt; Point&lt;T&gt; {\n    fn x(&amp;self) -&gt; &amp;T {\n        &amp;self.x\n    }\n}\n</code></pre>"},{"location":"rust-study/10-generic-type-traits-lifetimes/store_a_trait_in_a_struct/","title":"Store a trait in the struct","text":""},{"location":"rust-study/10-generic-type-traits-lifetimes/store_a_trait_in_a_struct/#purpose","title":"Purpose","text":"<p>Demonstrate how to store a trait in a struct.</p> <p>https://users.rust-lang.org/t/how-to-store-a-trait-as-field-of-a-struct/87762/2?u=rhtran</p> <pre><code>use std::{io::Read, fs::File};\n\nstruct Test&lt;'r&gt; {\n    readable: &amp;'r mut dyn Read,\n}\n\nimpl&lt;'r&gt; Test&lt;'r&gt; {\n    pub fn new(readable: &amp;'r mut dyn Read) -&gt; Self {\n        Self { readable }\n    }\n\n    pub fn read(&amp;mut self, buf: &amp;mut [u8]) {\n        self.readable.read(buf); // &lt;-- ERROR: cannot borrow data in an `Arc` as mutable\n    }\n}\n\nfn main() {\n    let mut file = File::open(\"foo.txt\").unwrap();\n    let test = Test::new(&amp;mut file);\n}\n</code></pre>"},{"location":"rust-study/10-generic-type-traits-lifetimes/traits/","title":"Traits","text":"<p>Traits are a way to define behavior in a generic way. They are similar to interfaces in other languages. A trait is a collection of methods that can be implemented by any type. Traits are useful for defining shared behavior in an abstract way. They are also useful for defining constraints on generic types.</p>"},{"location":"rust-study/10-generic-type-traits-lifetimes/traits/#defining-a-trait","title":"Defining a Trait","text":"<pre><code>trait Animal {\n    fn speak(&amp;self);\n}\n\nstruct Dog;\nstruct Cat;\n\nimpl Animal for Dog {\n    fn speak(&amp;self) {\n        println!(\"Woof!\");\n    }\n}\n\nimpl Animal for Cat {\n    fn speak(&amp;self) {\n        println!(\"Meow!\");;\n    }\n}\n</code></pre>"},{"location":"rust-study/10-generic-type-traits-lifetimes/traits/#default-implementations","title":"Default Implementations","text":"<p>Default implementations can be provided for traits. This allows you to provide a default implementation for a method in a trait. If a type implements the trait but does not provide an implementation for the method, the default implementation will be used.</p> <pre><code>fn main() {\n    trait Animal {\n        // Default implementation for the speak method\n        fn speak(&amp;self) -&gt; String {\n            \"I don't know what to say\".to_string()\n        }\n    }\n\n    struct Dog {\n        name: String,\n    }\n    struct Cat {\n        name: String,\n    }\n\n    struct Jellyfish {\n        name: String,\n    }\n\n    impl Animal for Dog {\n        fn speak(&amp;self) -&gt; String {\n            return \"Woof!\".to_string()\n        }\n    }\n\n    impl Animal for Cat {\n        fn speak(&amp;self) -&gt; String {\n            \"Meow!\".to_string()\n        }\n    }\n\n    // Jellyfish does not implement the speak method\n    impl Animal for Jellyfish{}\n\n    let dog = Dog { name: \"Rusty\".to_string() };\n    let cat = Cat { name: \"Misty\".to_string() };\n    let jellyfish =  Jellyfish{ name: \"Witty\".to_string() };\n\n    println!(\"{} says {}\", dog.name, dog.speak());\n    println!(\"{} says {}\", cat.name, cat.speak());\n    println!(\"{} says {}\", jellyfish.name, jellyfish.speak());\n}\n</code></pre>"},{"location":"rust-study/10-generic-type-traits-lifetimes/traits/#trait-as-parameters","title":"Trait as Parameters","text":"<pre><code>fn speak(animal: &amp;impl Animal) {\n    animal.speak();\n}\n</code></pre>"},{"location":"rust-study/10-generic-type-traits-lifetimes/traits/#trait-bounds","title":"Trait Bounds","text":"<pre><code>fn speak&lt;T: Animal&gt;(animal: &amp;T) {\n    animal.speak();\n}\n</code></pre>"},{"location":"rust-study/10-generic-type-traits-lifetimes/traits/#trait-as-return-type","title":"Trait as Return Type","text":"<pre><code>fn get_animal() -&gt; impl Animal {\n    Dog\n}\n</code></pre>"},{"location":"rust-study/10-generic-type-traits-lifetimes/traits/#conditional-trait-implementations","title":"Conditional Trait Implementations","text":"<pre><code>impl&lt;T: Animal&gt; Animal for Option&lt;T&gt; {\n    fn speak(&amp;self) {\n        match self {\n            Some(animal) =&gt; animal.speak(),\n            None =&gt; println!(\"No animal to speak\"),\n        }\n    }\n}\n</code></pre>"},{"location":"rust-study/10-generic-type-traits-lifetimes/traits/#advanced-traits","title":"Advanced Traits","text":"<pre><code>trait Animal {\n    fn speak(&amp;self);\n}\n</code></pre>"},{"location":"rust-study/10-generic-type-traits-lifetimes/type_chameleon/","title":"A Type Chameleon","text":"<p>In Rust, we can use a trait object to create a type that can hold any value that implements a specific trait. This is useful when we want to write functions that can accept any type that implements a trait.</p> <pre><code>fn(impl Trait)\nfn() -&gt; impl Trait\ntype = impl Trait\ntrait{fn() -&gt; impl Trait\n</code></pre>"},{"location":"rust-study/10-generic-type-traits-lifetimes/type_chameleon/#fn-impl-trait","title":"fn() -&gt; impl Trait","text":"<pre><code>fn only_true&lt;I&gt;(iter: I) -&gt; impl Iterator&lt;Item = bool&gt;\nwhere\n    I: Iterator&lt;Item = bool&gt;,\n{\n    iter.filter(|&amp;x| x)\n}\n</code></pre>"},{"location":"rust-study/10-generic-type-traits-lifetimes/type_chameleon/#struct-traits-and-impl","title":"Struct, Traits, and Impl","text":"<pre><code>struct DougsData {\n    some_boot: bool,\n    some_float: f32,\n    some_int: i32,\n}\n</code></pre>"},{"location":"rust-study/13-functional-programming/fp/","title":"Functional Programming","text":""},{"location":"rust-study/13-functional-programming/oop/","title":"Object Oriented Programming in Rust","text":""},{"location":"rust-study/13-functional-programming/oop/#create-a-rectangle-class","title":"Create a Rectangle Class","text":"<pre><code>struct Rectangle {\n    width: u32,\n    height: u32,\n}\n</code></pre>"},{"location":"rust-study/13-functional-programming/oop/#create-rectangle-methodsfunctions","title":"Create Rectangle Methods/Functions","text":"<pre><code>impl Rectangle {\n    fn area(&amp;self) -&gt; u32 {\n        self.width * self.height\n    }\n\n    fn perimeter(&amp;self) -&gt; u32 {\n        2 * (self.width + self.height)\n    }\n}\n</code></pre>"},{"location":"rust-study/13-functional-programming/oop/#create-a-rectangle-instance","title":"Create a Rectangle Instance","text":"<pre><code>fn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\"The area of the rectangle is {} square pixels.\", rect1.area());\n    println!(\"The perimeter of the rectangle is {} pixels.\", rect1.perimeter());\n}\n</code></pre>"},{"location":"rust-study/13-functional-programming/oop/#create-polymorphism-in-rust","title":"Create Polymorphism in Rust","text":"<pre><code>trait Shape {\n    fn area(&amp;self) -&gt; u32;\n    fn perimeter(&amp;self) -&gt; u32;\n}\n\nimpl Shape for Rectangle {\n    fn area(&amp;self) -&gt; u32 {\n        self.width * self.height\n    }\n\n    fn perimeter(&amp;self) -&gt; u32 {\n        2 * (self.width + self.height)\n    }\n}\n\nimpl Shape for Circle {\n    fn area(&amp;self) -&gt; u32 {\n        (self.radius * self.radius) * 3\n    }\n\n    fn perimeter(&amp;self) -&gt; u32 {\n        2 * self.radius * 3\n    }\n}\n\nfn print_shape(shape: &amp;dyn Shape) {\n    println!(\"The area of the shape is {} square pixels.\", shape.area());\n    println!(\"The perimeter of the shape is {} pixels.\", shape.perimeter());\n}\n</code></pre>"},{"location":"rust-study/14-smart-pointer/smart-pointer/","title":"Smart Pointer","text":"<p>In Rust, a smart pointer is a class that wraps a raw pointer and provides additional functionality.</p>"},{"location":"rust-study/14-smart-pointer/smart-pointer/#box","title":"Box","text":"<p>Box is a smart pointer that points to heap-allocated data. It is used:</p> <ul> <li>when you have a fixed size data that you want to store on the heap.</li> <li>when you have a large amount of data, and you want to transfer ownership but ensure that the data is not copied.</li> <li>when you have a data structure that is recursive, and you want to store it on the heap.</li> <li>when you have a trait object rather than a struct, and you want to store it on the heap.</li> </ul> <pre><code>use std::mem;\n\n#[derive(Debug, Clone, Copy)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n// A Rectangle can be specified by where its top left and bottom right \n// corners are in space\n#[allow(dead_code)]\nstruct Rectangle {\n    top_left: Point,\n    bottom_right: Point,\n}\n\nfn origin() -&gt; Point {\n    Point { x: 0.0, y: 0.0 }\n}\n\nfn boxed_origin() -&gt; Box&lt;Point&gt; {\n    // Allocate this point on the heap, and return a pointer to it\n    Box::new(Point { x: 0.0, y: 0.0 })\n}\n\nfn main() {\n    // (all the type annotations are superfluous)\n    // Stack allocated variables\n    let point: Point = origin();\n    let rectangle: Rectangle = Rectangle {\n        top_left: origin(),\n        bottom_right: Point { x: 3.0, y: -4.0 }\n    };\n\n    // Heap allocated rectangle\n    let boxed_rectangle: Box&lt;Rectangle&gt; = Box::new(Rectangle {\n        top_left: origin(),\n        bottom_right: Point { x: 3.0, y: -4.0 },\n    });\n\n    // The output of functions can be boxed\n    let boxed_point: Box&lt;Point&gt; = Box::new(origin());\n\n    // Double indirection\n    let box_in_a_box: Box&lt;Box&lt;Point&gt;&gt; = Box::new(boxed_origin());\n\n    println!(\"Point occupies {} bytes on the stack\",\n             mem::size_of_val(&amp;point));\n    println!(\"Rectangle occupies {} bytes on the stack\",\n             mem::size_of_val(&amp;rectangle));\n\n    // box size == pointer size\n    println!(\"Boxed point occupies {} bytes on the stack\",\n             mem::size_of_val(&amp;boxed_point));\n    println!(\"Boxed rectangle occupies {} bytes on the stack\",\n             mem::size_of_val(&amp;boxed_rectangle));\n    println!(\"Boxed box occupies {} bytes on the stack\",\n             mem::size_of_val(&amp;box_in_a_box));\n\n    // Copy the data contained in `boxed_point` into `unboxed_point`\n    let unboxed_point: Point = *boxed_point;\n    println!(\"Unboxed point occupies {} bytes on the stack\",\n             mem::size_of_val(&amp;unboxed_point));\n}\n</code></pre> <p>Recursive data structure example:</p> <pre><code>// Compiler error: recursive type `List` has infinite size, therefore Box&lt;T&gt; is needed.\nenum List {\n    // Cons(i32, List), // Compiler error\n    Cons(i32, Box&lt;List&gt;),\n    Nil,\n}\n\nuse List::{Cons, Nil};\n\nfn main() {\n    let list = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n}\n</code></pre>"},{"location":"rust-study/14-smart-pointer/smart-pointer/#deref","title":"Deref","text":""},{"location":"rust-study/14-smart-pointer/smart-pointer/#rc","title":"Rc","text":"<p>Rc is a reference counting smart pointer. It is used when you want to have multiple ownership of a value. Rc is a non-atomic reference counting smart pointer. It is not thread safe. If you want to use Rc in a multi-threaded environment, you should use Arc instead.</p> <pre><code>use std::rc::Rc;\n\nfn main() {\n    let rc_examples = \"Rc examples\".to_string();\n    {\n        println!(\"--- rc_a is created ---\");\n\n        let rc_a: Rc&lt;String&gt; = Rc::new(rc_examples);\n        println!(\"Reference Count of rc_a: {}\", Rc::strong_count(&amp;rc_a));\n\n        {\n            println!(\"--- rc_a is cloned to rc_b ---\");\n\n            let rc_b: Rc&lt;String&gt; = Rc::clone(&amp;rc_a);\n            println!(\"Reference Count of rc_b: {}\", Rc::strong_count(&amp;rc_b));\n            println!(\"Reference Count of rc_a: {}\", Rc::strong_count(&amp;rc_a));\n\n            // Two `Rc`s are equal if their inner values are equal\n            println!(\"rc_a and rc_b are equal: {}\", rc_a.eq(&amp;rc_b));\n\n            // We can use methods of a value directly\n            println!(\"Length of the value inside rc_a: {}\", rc_a.len());\n            println!(\"Value of rc_b: {}\", rc_b);\n\n            println!(\"--- rc_b is dropped out of scope ---\");\n        }\n\n        println!(\"Reference Count of rc_a: {}\", Rc::strong_count(&amp;rc_a));\n\n        println!(\"--- rc_a is dropped out of scope ---\");\n    }\n\n    // Error! `rc_examples` already moved into `rc_a`\n    // And when `rc_a` is dropped, `rc_examples` is dropped together\n    // println!(\"rc_examples: {}\", rc_examples);\n    // TODO ^ Try uncommenting this line\n}\n</code></pre>"},{"location":"rust-study/14-smart-pointer/smart-pointer/#arc","title":"Arc","text":"<p>Arc is an atomic reference counting smart pointer. It is used when you want to have multiple ownership of a value in a multi-threaded environment.</p> <pre><code>use std::time::Duration;\nuse std::sync::Arc;\nuse std::thread;\n\nfn main() {\n    // This variable declaration is where its value is specified.\n    let apple = Arc::new(\"the same apple\");\n\n    for _ in 0..10 {\n        // Here there is no value specification as it is a pointer to a\n        // reference in the memory heap.\n        let apple = Arc::clone(&amp;apple);\n\n        thread::spawn(move || {\n            // As Arc was used, threads can be spawned using the value allocated\n            // in the Arc variable pointer's location.\n            println!(\"{:?}\", apple);\n        });\n    }\n\n    // Make sure all Arc instances are printed from spawned threads.\n    thread::sleep(Duration::from_secs(1));\n}\n</code></pre>"},{"location":"rust-study/14-smart-pointer/smart-pointer/#refcell","title":"RefCell","text":"<p>A RefCell is another way to change values without needing to declare mut. It means \"reference cell,\" and is like a Cell but uses references instead of copies.</p> <pre><code>use std::cell::RefCell;\n\n#[derive(Debug)]\nstruct User {\n    id: u32,\n    year_registered: u32,\n    username: String,\n    active: RefCell&lt;bool&gt;,\n    // Many other fields\n}\n\nfn main() {\n    let user_1 = User {\n        id: 1,\n        year_registered: 2020,\n        username: \"User 1\".to_string(),\n        active: RefCell::new(true),\n    };\n\n    println!(\"{:?}\", user_1.active);\n}\n</code></pre>"},{"location":"rust-study/14-smart-pointer/smart-pointer/#cell","title":"Cell","text":""},{"location":"rust-study/15-concurrency/concurrency/","title":"Rust Concurrency","text":"<ul> <li>Threads</li> <li>Message Channels</li> <li>Mutexes and Atomic Variables</li> </ul>"},{"location":"rust-study/15-concurrency/concurrency/#threads","title":"Threads","text":""},{"location":"rust-study/15-concurrency/concurrency/#common-concurrency-errors","title":"Common Concurrency Errors","text":"<p>Race Conditions: Threads interact with data in an unpredictable way. This can lead to data corruption and other issues.</p> <p>Deadlocks: Threads are waiting for each other to release a resource that they need. This can lead to a situation where no thread can make progress.</p>"},{"location":"rust-study/15-concurrency/concurrency/#creating-threads","title":"Creating Threads","text":"<p>Use the <code>thread::spawn</code> function to create a new thread.</p> <pre><code>use std::thread;\n\n/// This function spawns a new thread and prints a message from the main thread and the new thread.\n/// However, the new thread will not finish before the main thread exits.\nfn main() {\n    // Spawn a new thread\n    thread::spawn(|| {\n        // Print a message from the new thread\n        println!(\"hello from thread\");\n    });\n\n    println!(\"hello from main\")\n}\n</code></pre>"},{"location":"rust-study/15-concurrency/concurrency/#joining-threads","title":"Joining Threads","text":"<p>Use the <code>join</code> method to wait for a thread to finish.</p> <pre><code>use std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..11 {\n            println!(\"counter from thread {}\", i);\n            thread::sleep(Duration::from_millis(2_000));\n        }\n    });\n\n    // fn join(self) - Waits for the associated thread to finish\n    // join() is a blocking operation, meaning that it will block the current thread until the associated thread has finished.\n    // In this case, it will block the main thread until the spawned thread finishes\n    handle.join().unwrap();\n    println!(\"Thread has finished.\");\n\n    for i in 1..11 {\n        println!(\"counter from main {}\", i);\n        thread::sleep(Duration::from_millis(1_000));\n    }\n}\n</code></pre>"},{"location":"rust-study/15-concurrency/concurrency/#closure-and-threads","title":"Closure and Threads","text":"<p>When you create a closure, it captures the environment in which it is created. This means that it can access variables from the surrounding scope.</p> <pre><code>use std::thread;\nuse std::thread::JoinHandle;\n\nfn main() {\n    // Create a vector to hold the child-threads\n    let mut handles: Vec&lt;JoinHandle&lt;()&gt;&gt; = vec![];\n\n    for i in 1..11 {\n        // need to move i into the closure to avoid the error\n        let handle: JoinHandle&lt;()&gt; = thread::spawn( move || {\n            println!(\"counter from thread {}\", i);\n        });\n\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n</code></pre>"},{"location":"rust-study/15-concurrency/concurrency/#message-channels","title":"Message Channels","text":"<p>Channels are a way to send messages between threads. They are a way to communicate between threads without sharing memory.</p>"},{"location":"rust-study/15-concurrency/concurrency/#creating-a-channel","title":"Creating a Channel","text":"<p>Use the <code>channel</code> function to create a channel. The function returns a tuple with a <code>Sender</code> (tx) and a <code>Receiver</code> (rx).</p> <pre><code>use std::sync::mpsc;\n</code></pre> <p>Common Currency Errors:</p> <ul> <li>Race Conditions - Threads interact with data in an unpredictable way. This can lead to data corruption and other   issues.</li> <li>Deadlocks - Threads are waiting for each other to release a resource that they need. This can lead to a situation   where no thread can make progress.</li> <li>Starvation - A thread is unable to make progress because it is waiting for a resource that is being held by another   thread.</li> </ul> <pre><code>use std::sync::mpsc::channel;\nuse std::thread::{JoinHandle, spawn};\n\nfn main() {\n    // Create a channel\n    let (tx, rx) = channel();\n\n    // Create a vector to hold the child-threads\n    let mut handles: Vec&lt;std::thread::JoinHandle&lt;()&gt;&gt; = vec![];\n\n    // Create 10 threads and send the counter-value to the channel\n    for i in 1..11 {\n        // need to move i into the closure to avoid the error\n        let tx_clone = tx.clone();\n        let handle: JoinHandle&lt;()&gt; = spawn( move || {\n            tx_clone.send(i).unwrap();\n        });\n\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    drop(tx);\n\n    // Receive the counter-values from the channel\n    // Receiver will block until all the senders are done\n    for received in rx {\n        println!(\"Got: {}\", received);\n    }\n}\n</code></pre>"},{"location":"rust-study/15-concurrency/concurrency/#unbounded-channels","title":"Unbounded Channels","text":"<p>The <code>channel</code> function creates an unbounded channel. This means that the channel can hold an unlimited number of messages.</p> <pre><code>use std::sync::mpsc::channel;\n\nfn main() {\n    // Create a bounded channel\n    let (tx, rx) = sync_channel();\n}\n</code></pre>"},{"location":"rust-study/15-concurrency/concurrency/#bounded-channels","title":"Bounded Channels","text":"<p>The <code>sync::mpsc::channel</code> function can be used to create a bounded channel. This means that the channel can hold a limited number of messages.</p> <pre><code>use std::sync::mpsc::{channel, sync_channel};\n\nfn main() {\n    // Create a bounded channel\n    let (tx, rx) = sync_channel(3);\n}\n</code></pre>"},{"location":"rust-study/15-concurrency/concurrency/#blocking-and-non-blocking-channels","title":"Blocking and Non-Blocking Channels","text":"<p>The <code>send</code> and <code>recv</code> methods are blocking. This means that they will block the thread until the operation is complete. The <code>try_send</code> and <code>try_recv</code> methods are non-blocking. This means that they will return an error if the operation cannot be completed immediately.</p> <pre><code>use std::sync::mpsc::channel;\n</code></pre>"},{"location":"rust-study/15-concurrency/concurrency/#mutexes-and-atomic-variables","title":"Mutexes and Atomic Variables","text":"<p>Mutexes are a way to share data between threads. They are a way to protect data.</p>"},{"location":"rust-study/15-concurrency/concurrency/#creating-a-mutex","title":"Creating a Mutex","text":"<p>Use the <code>Mutex</code> struct to create a mutex. The <code>lock</code> method is used to acquire the lock. The <code>unlock</code> method is used to release the lock.</p> <pre><code>use std::sync::Mutex;\n</code></pre>"},{"location":"rust-study/15-concurrency/concurrency/#mutexes-and-threads","title":"Mutexes and Threads","text":"<p>Mutexes can be used to share data between threads. The <code>lock</code> method is used to acquire the lock. The <code>unlock</code> method is used to release the lock.</p> <pre><code>use std::sync::Mutex;\nuse std::thread::{JoinHandle, spawn};\n</code></pre>"},{"location":"rust-study/15-concurrency/tokio-concurrency/","title":"Concurrency with Tokio","text":"<p>Asynchronous programming in Tokio is based on the <code>Future</code> trait. A <code>Future</code> is a computation that may not have finished yet. Tokio provides a runtime that can execute these futures concurrently. This allows you to write asynchronous code that is non-blocking and efficient. In this guide, we will explore how to write asynchronous code using Tokio.</p> <pre><code>/// The async keyword is used to define an asynchronous function.\nasync fn hello_world() -&gt; String {\n    \"Hello, World!\".to_string()\n}\n\n/// The #[tokio::main] attribute is used to define the entry point of a Tokio application.\n#[tokio::main]\nasync fn main() {\n    // the hello_world function returns a future that will be executed by the Tokio runtime\n    let result = hello_world().await;\n    println!(\"{}\", result);\n}\n</code></pre> <p>tokio::main is a macro that sets up the Tokio runtime and runs the async main function. The async keyword is used to define an asynchronous function. Its functionality looks like this:</p> <pre><code>fn main() {\n    let result = tokio::runtime::Runtime::Builder::new_current_thread()\n        .enable_all()\n        .build()\n        .unwrap()\n        .block_on(async { println!(\"Hello World\"); });\n}\n</code></pre>"},{"location":"rust-study/15-concurrency/tokio-concurrency/#testing-asynchronous-code","title":"Testing Asynchronous Code","text":"<p>Testing asynchronous code can be challenging. Tokio provides a testing framework that makes it easy to test asynchronous code. The <code>tokio::test</code> attribute is used to define an asynchronous test function. The <code>tokio::test</code> attribute sets up the Tokio runtime and runs the test function asynchronously. Here is an example of how to test an asynchronous function:</p> <pre><code>#[tokio::test]\nasync fn test_hello_world() {\n    let result = hello_world().await;\n    assert_eq!(result, \"Hello, World!\");\n}\n</code></pre>"},{"location":"rust-study/15-concurrency/tokio-concurrency/#channels","title":"Channels","text":"<p>Channels are a way to communicate between threads. Tokio provides a channel implementation that allows you to send messages between asynchronous tasks. The <code>tokio::sync::mpsc</code> module provides a channel implementation that is similar to the standard library's <code>std::sync::mpsc</code> module. Here is an example of how to use a channel:</p>"},{"location":"rust-study/15-concurrency/tokio-concurrency/#oneshot-channel","title":"oneshot Channel","text":"<p>The <code>tokio::sync::oneshot</code> module provides a channel implementation that allows you to send a single message between asynchronous tasks. The <code>tokio::sync::oneshot::channel</code> function creates a oneshot channel that returns a <code>Sender</code> and a <code>Receiver</code>. Here is an example of how to use a oneshot channel:</p> <pre><code>use tokio::sync::oneshot;\n\nfn main() {\n    let (tx, rx) = oneshot::channel();\n\n    tokio::spawn(async move {\n        let _ = tx.send(\"Hello, World!\");\n    });\n\n    tokio::spawn(async move {\n        let result = rx.await.unwrap();\n        println!(\"{}\", result);\n    });\n}\n</code></pre>"},{"location":"rust-study/15-concurrency/tokio-concurrency/#mpsc-channel","title":"mpsc Channel","text":"<p>The <code>tokio::sync::mpsc</code> module provides a channel implementation that allows you to send messages between asynchronous tasks. The <code>tokio::sync::mpsc::channel</code> function creates a mpsc channel that returns a <code>Sender</code> and a <code>Receiver</code>. Here is an example of how to use a mpsc channel:</p> <pre><code>use tokio::sync::mpsc;\n\nfn main() {\n    let (tx, mut rx) = mpsc::channel(32);\n\n    tokio::spawn(async move {\n        tx.send(\"Hello, World!\").await.unwrap();\n    });\n\n    tokio::spawn(async move {\n        while let Some(message) = rx.recv().await {\n            println!(\"{}\", message);\n        }\n    });\n}\n</code></pre>"},{"location":"rust-study/16-ioc/1-trait-impl/","title":"IoC in Rust","text":"<p>Inversion of Control (IoC) is a design principle in which the flow of control of a system is inverted. In IoC, the control of the program is transferred to a container or framework. The container or framework manages the dependencies of the application. The IoC principle is implemented in Rust using traits and generics.</p> <p>In service.rs,</p> <pre><code>// Write me a sample trait and struct that uses the trait as a field.\npub trait Repoer {\n    fn get(&amp;self) -&gt; String;\n}\n\npub struct Repo {\n    data: String,\n}\n\nimpl Repo {\n    pub fn new() -&gt; Self {\n        Repo {\n            data: \"Hello, World!\".to_string(),\n        }\n    }\n}\n\nimpl Repoer for Repo {\n    fn get(&amp;self) -&gt; String {\n        self.data.clone()\n    }\n}\n\npub trait Servicer {\n    fn get(&amp;self) -&gt; String;\n}\n\npub(crate) struct Service {\n    repo: Box&lt;dyn Repoer + 'static&gt;,\n}\n\nimpl Service {\n    pub fn new(repo: Box&lt;dyn Repoer + 'static&gt;) -&gt; Self {\n        Service {\n            repo,\n        }\n    }\n\n}\nimpl Servicer for Service {\n\n    fn get(&amp;self) -&gt; String {\n        self.repo.get()\n    }\n}\n</code></pre> <p>main.rs</p> <pre><code>mod service;\nuse crate::service::{Servicer};\n\n#[tokio::main]\nasync fn main() {\n    let repo = Box::new(crate::service::Repo::new());\n    let service = crate::service::Service::new(repo);\n\n    println!(\"{}\", service.get());\n}\n</code></pre> <p>This code won't work if implement async traits to 'async fn get(&amp;self)'. The error message is:</p> <pre><code>error[E0038]: the trait `Repoer` cannot be made into an object\n  --&gt; src/service.rs:29:15\n   |\n29 |     repo: Box&lt;dyn Repoer + 'static&gt;,\n   |               ^^^^^^^^^^^^^^^^^^^^ `Repoer` cannot be made into an object\n   |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit &lt;https://doc.rust-lang.org/reference/items/traits.html#object-safety&gt;\n  --&gt; src/service.rs:3:14\n   |\n2  | pub trait Repoer {\n   |           ------ this trait cannot be made into an object...\n3  |     async fn get(&amp;self) -&gt; String;\n   |              ^^^ ...because method `get` is `async`\n   = help: consider moving `get` to another trait\n   = help: only type `service::Repo` implements the trait, consider using it directly instead\n</code></pre> <p>To fix this, we need to split the trait into two traits, one for async and one for sync. The code will look like this: in service.rs</p> <pre><code>// Write me a sample trait and struct that uses the trait as a field.\npub trait Repoer {\n    async fn get(&amp;self) -&gt; String;\n}\n\npub struct Repo {\n    data: String,\n}\n\n// Inject constructor - inject the dependency (DB) into the struct\nimpl Repo {\n    pub fn new() -&gt; Self {\n        Repo {\n            data: \"Hello, DB!\".to_string(),\n        }\n    }\n}\n\nimpl Repoer for Repo {\n    async fn get(&amp;self) -&gt; String {\n        self.data.clone()\n    }\n}\n\npub trait Servicer {\n    async fn get(&amp;self) -&gt; String;\n}\n\npub struct Service&lt;R&gt; {\n    repo: R,\n}\n\n// Constructor injection - inject the dependency (repo) into the struct\nimpl&lt;R&gt; Service&lt;R&gt; {\n    pub fn new(repo: R) -&gt; Self{\n        Service {\n            repo,\n        }\n    }\n\n}\nimpl&lt;R&gt; Servicer for Service&lt;R&gt; where R: Repoer {\n    async fn get(&amp;self) -&gt; String {\n        self.repo.get().await\n    }\n}\n</code></pre> <p>in main.rs</p> <pre><code>#[tokio::main]\nasync fn main() {\n    let repo = service::Repo::new();\n    let service = crate::service::Service::new(repo);\n\n    println!(\"{}\", service.get().await);\n}\n</code></pre> <p>This example demonstrates how to implement IoC in Rust using traits and generics.</p> Service has two dependencies, Repo and Gateway. The Repo and Gateway are injected into the Service struct using constructor injection. The Service struct implements the Servicer trait, which has a get method that returns a string. The get method calls the get method of the Repo and Gateway dependencies and concatenates the results. <pre><code>// Write me a sample trait and struct that uses the trait as a field.\npub trait Repoer {\n    async fn get(&amp;self) -&gt; String;\n}\n\npub struct Repo {\n    data: String,\n}\n\n// Inject constructor - inject the dependency (DB) into the struct\nimpl Repo {\n    pub fn new() -&gt; Self {\n        Repo {\n            data: \"Hello, Data!\".to_string(),\n        }\n    }\n}\n\nimpl Repoer for Repo {\n    async fn get(&amp;self) -&gt; String {\n        self.data.clone()\n    }\n}\n\ntrait Gatewayer {\n    async fn get(&amp;self) -&gt; String;\n}\n\npub struct Gateway {}\n\nimpl Gateway {\n    pub fn new() -&gt; Self {\n        Gateway {}\n    }\n}\n\nimpl Gatewayer for Gateway {\n    async fn get(&amp;self) -&gt; String {\n        \"Hello, Gateway\".to_string()\n    }\n}\n\npub trait Servicer {\n    async fn get(&amp;self) -&gt; String;\n}\n\npub struct Service&lt;R, G&gt; {\n    repo: R,\n    gateway: G\n}\n\n// Constructor injection - inject the dependency (repo) into the struct\nimpl&lt;R, G&gt; Service&lt;R, G&gt; {\n    pub fn new(repo: R, gateway: G) -&gt; Self{\n        Service {\n            repo,\n            gateway,\n        }\n    }\n\n}\nimpl&lt;R, G&gt; Servicer for Service&lt;R, G&gt; where R: Repoer, G: Gatewayer {\n    async fn get(&amp;self) -&gt; String {\n        self.repo.get().await + \"  \" + self.gateway.get().await.as_str()\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    let repo = service::Repo::new();\n    let gateway = service::Gateway::new();\n    let service = crate::service::Service::new(repo, gateway);\n\n    println!(\"{}\", service.get().await);\n}\n</code></pre>"},{"location":"rust-study/20-aws-lambda/1-rust-on-aws-lambda/","title":"Deploying Rust Functions on AWS Lambda","text":"<p>This is documentation for the developer preview release of the AWS SDK for Rust. Do not use it in production as it is subject to breaking changes.</p>"},{"location":"rust-study/20-aws-lambda/1-rust-on-aws-lambda/#creating-the-rust-program","title":"Creating the Rust Program","text":"<pre><code>cargo lambda new rust-base-aws-lambda-examples\n</code></pre>"},{"location":"rust-study/20-aws-lambda/2-rust-in-aws-lambda/","title":"Using the AWS SDK for Rust in AWS Lambda function","text":"<p>This is documentation for the developer preview release of the AWS SDK for Rust. Do not use it in production as it is subject to breaking changes.</p>"},{"location":"rust-study/21-unit-test/01-unit-test/","title":"Rust Test Functions","text":"<p>In his 1972 essay \u201cThe Humble Programmer,\u201d Edsger W. Dijkstra said that \u201cProgram testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.\u201d</p> <ul> <li>Define using the #[test] attribute</li> <li>Run with cargo test command</li> </ul>"},{"location":"rust-study/21-unit-test/01-unit-test/#assert-macro","title":"assert! Macro","text":"<ul> <li>Evaluates a single Boolean argument</li> <li>if true, do nothing</li> <li>if false, call the panic! macro</li> </ul> <p>assert_eq! assert_ne!</p>"},{"location":"rust-study/21-unit-test/01-unit-test/#should_panic","title":"Should_panic","text":"<ul> <li>add #[should_panic(expected=\"message\")] if the code expects panic. This functionality is similar to Java @Exception</li> </ul>"},{"location":"rust-study/21-unit-test/01-unit-test/#test-filter","title":"Test Filter","text":"<pre><code>cargo test test_name\n</code></pre>"},{"location":"rust-study/21-unit-test/01-unit-test/#ignoring-tests","title":"Ignoring Tests","text":"<pre><code>#[ignore]\n</code></pre>"},{"location":"rust-study/21-unit-test/02-mocking/","title":"Mocking in Rust","text":"<p>To test a component in isolation, we need to mock the dependencies of the component. Mocking is a technique used in unit testing when a component is dependent on another component that is difficult to test. Mocking is used to isolate the component under test from the rest of the system. Mocking is used to simulate the behavior of the dependent component.</p> <ul> <li>Mocking is a technique used in unit testing when a component is dependent on another component that is difficult to   test.</li> <li>Mocking is used to isolate the component under test from the rest of the system.</li> <li>Mocking is used to simulate the behavior of the dependent component.</li> </ul> <p>In a unit test, mock object can simulate teh behavior of complex, real objects and are therefore useful when a read object is impractical or impossible to incorporate into a unit test.</p> <p>Mon-Deterministic Resources</p> <ul> <li>External APIs</li> <li>Databases</li> <li>Resources using global state</li> <li>Time-dependent resources</li> <li>Environment variables</li> </ul> <p>Mocking would control the behavior of these resources and make the test deterministic.</p>"},{"location":"rust-study/21-unit-test/02-mocking/#reason-for-mocking","title":"Reason for Mocking","text":"<ul> <li>Isolation of Components for Unit Testing</li> <li>Improved Test Stability &amp; Reliability</li> <li>Efficiency and Speed</li> </ul>"},{"location":"rust-study/21-unit-test/02-mocking/#mockall","title":"Mockall","text":"<p>There are several libraries available in Rust for mocking. One of the popular libraries is Mockall. Mockall is a Rust library for mocking traits. Mockall generates mock objects for traits at compile time.</p> <p>add mockall crate to Cargo.toml</p> <pre><code>mockall = {version = \"0.12.1\"}\n</code></pre> <ul> <li>Must refactor to traits implementation in order to mock</li> <li>Use <code>Mockall</code> crate to generate mock objects</li> <li>Use Mock to create a mock object <p>for example:</p> <pre><code>use std::arch::{is_arm_feature_detected, is_mips_feature_detected};\nuse mockall::automock;\n\n#[automock]\npub trait ProductServicer {\n    fn get_product_by_id(&amp;self, id: i32) -&gt; Result&lt;Product, Error&gt;;\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_get_product_by_id() {\n        let mut product_service = ProductServicer::new();\n        product_service.expect_run().times(1).returning(|| println!(\"ProductServicer::run\"));\n\n        product_service.get_product_by_id(1);\n    }\n}\n\nfn main() {\n    let product_service = MockProductServicer::new();\n    let product = product_service.get_product_by_id(1);\n}\n</code></pre>"},{"location":"rust-study/22-project-organization/layer-design/","title":"Layer design","text":"<p>The first approach would look something like :</p> <p>trait UserService { ... } struct UserServiceImpl { repository: Arc } impl UserService for UserServiceImpl { .. } <p>trait UserRepository { ... } struct UserRepositoryImpl { ... } impl UserRepository for UserRepositoryImpl The second would be :</p> <p>trait UserService { ... } struct UserServiceImpl { repository: Arc } impl UserService for UserServiceImpl { .. }"},{"location":"rust-study/22-project-organization/rust-project-manager/","title":"Rust: Managing Projects","text":""},{"location":"rust-study/22-project-organization/rust-project-manager/#modules","title":"Modules","text":"<ul> <li>Subdivide code to group related functionalities / items</li> <li>Provide isolated namespaces to control scope and privacy</li> <li>Modules can contain:<ul> <li>Structs</li> <li>Enums</li> <li>Traits</li> <li>Functions</li> <li>Impl blocks</li> <li>Constants</li> <li>Other modules</li> </ul> </li> </ul>"},{"location":"rust-study/22-project-organization/rust-project-manager/#paths","title":"Paths","text":"<ul> <li>Reference items with the module system</li> <li>Can be relative or absolute</li> </ul>"},{"location":"rust-study/22-project-organization/rust-project-manager/#crates","title":"Crates","text":"<ul> <li>A binary</li> <li>library</li> </ul>"},{"location":"rust-study/22-project-organization/rust-project-manager/#packages","title":"Packages","text":"<ul> <li>Used to build, test, and share crates with Cargo</li> <li>Contains one or more target crates<ul> <li>Up to one library crate</li> <li>Zero or more binary crates</li> </ul> </li> <li>Consists of a Cargo.toml file and collection of source files</li> <li>Can contain multiple crates</li> <li>Can contain multiple binaries inside bin directory</li> <li>Compile all binaries with <code>cargo build --all</code> or 'cargo build --workspace'</li> <li>Can compile a specific binary with <code>cargo build --bin &lt;binary_name&gt;</code></li> </ul> <p>One note: super keyword: reference parent module</p> <p>Inline module example:</p> <pre><code>fn main() {\n    println!(\"Hello, world!\");\n}\n\nmod hello {\n    fn english() {\n        println!(\"hello\");\n    }\n\n    fn spanish() {\n        println!(\"hola\");\n    }\n\n    mod casual {\n        fn english() {\n            println!(\"hey\");\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"rust-study/22-project-organization/rust-project-manager/#defining-modules-in-separate-directories","title":"Defining Modules in Separate Directories","text":"<ul> <li>Create a new directory for each module</li> <li>Create a new file for each module</li> </ul>"},{"location":"rust-study/Hands-On-Concurrency-with-Rust-master/","title":"Hands-On Concurrency with Rust","text":"<p>This is the code repository for Hands-On Concurrency with Rust, published by Packt. It contains all the supporting project files necessary to work through the book from start to finish.</p>"},{"location":"rust-study/Hands-On-Concurrency-with-Rust-master/#about-the-book","title":"About the Book","text":"<p>Most programming languages can really complicate things, especially with regard to unsafe memory access. The burden on you, the programmer, lies across two domains: understanding the modern machine and your language's pain-points. This book will teach you to how to manage program performance on modern machines and build fast, memory-safe, and concurrent software in Rust. It starts with the fundamentals of Rust and discusses machine architecture concepts. You will be taken through ways to measure and improve the performance of Rust code systematically and how to write collections with confidence. You will learn about the Sync and Send traits applied to threads, and coordinate thread execution with locks, atomic primitives, data-parallelism, and more.</p>"},{"location":"rust-study/Hands-On-Concurrency-with-Rust-master/#instructions-and-navigation","title":"Instructions and Navigation","text":"<p>All of the code is organized into folders. Each folder starts with a number followed by the application name. For example, Chapter02.</p> <p>All codes are present in theit respective folders.</p> <p>The code will look like the following:</p> <pre><code>fn main() {\n  println!(\"Apollo is the name of a space program but also my dog.\");\n}\n</code></pre>"},{"location":"rust-study/Hands-On-Concurrency-with-Rust-master/#authors-instruction","title":"Author's Instruction","text":"<p>Rust Concurrency discusses several community projects. This repository tracks those crates as submodules. To properly initialize this repository please issue the following commands:</p> <pre><code>&gt; git submodule init\n&gt; git submodule update\n</code></pre> <p>If you have not yet cloned the repository and have at least git 2.13 you may issue this command instead:</p> <pre><code>&gt; git clone --recurse-submodules https://github.com/PacktPublishing/Rust-Concurrency.git\n</code></pre> <p>If this is your first Rust programming book, I warmly thank you for your enthusiasm, but encourage you to seek out a suitable introduction to the programming language. This book will hit the ground running, and it will likely not be appropriate if you've got questions about the basics. The Rust community has produced excellent documentation, including introductory texts. The Book (https:/\u200b/\u200bdoc.\u200brust-\u200blang.\u200borg/\u200bbook/\u200bfirst-\u200bedition/\u200b), first edition, is how many who are already in the community learned the language. The second edition of the book, still in progress at the time of writing, looks to be an improvement over the original text, and it is also recommended. There are many other excellent introductions widely available for purchase, as well.</p>"},{"location":"rust-study/Hands-On-Concurrency-with-Rust-master/#related-products","title":"Related Products","text":"<ul> <li> <p>Rust Programming By Example</p> </li> <li> <p>Rust Cookbook</p> </li> <li> <p>Rust Essentials - Second Edition</p> </li> </ul>"},{"location":"rust-study/Hands-On-Concurrency-with-Rust-master/#download-a-free-pdf","title":"Download a free PDF","text":"<p>If you have already purchased a print or Kindle version of this book, you can get a DRM-free PDF version at no cost.Simply click on the link to claim your free PDF.</p> <p> https://packt.link/free-ebook/9781788399975  </p>"}]}